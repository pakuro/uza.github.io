<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>War Strategy: FINAL BOSS</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Arial Black', sans-serif; user-select: none; }
        
        canvas { display: block; width: 100vw; height: 100vh; background: #87CEEB; }

        /* UIエリア */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 140px;
            background: rgba(0,0,0,0.85); border-top: 4px solid #fff;
            display: flex; justify-content: center; align-items: center; gap: 10px;
            padding-bottom: 10px; z-index: 10;
        }

        .btn {
            width: 100px; height: 90px;
            background: #444; color: white; border: 2px solid #666; border-radius: 8px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; position: relative; transition: 0.1s;
            box-shadow: 0 4px 0 #222;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; background: #555; }
        .btn.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); transform: none; box-shadow: none;}
        .cost { color: #ffff00; font-size: 14px; margin-top: 5px; }
        .name { font-size: 14px; font-weight: bold; }
        
        /* タイタンボタン（特別仕様） */
        #btn-titan { background: #aa8800; border-color: #ffcc00; width: 120px; }
        #btn-titan .name { font-size: 18px; color: #fff; text-shadow: 0 0 5px gold; }

        #btn-upgrade { background: #0055aa; border-color: #0077cc; }

        #money-display {
            position: absolute; top: -60px; left: 20px;
            color: #ffff00; font-size: 40px; text-shadow: 3px 3px 0 #000;
            font-family: 'Courier New', monospace; font-weight: bold;
        }

        /* ボス出現警告 */
        #boss-warning {
            position: absolute; top: 30%; left: 0; width: 100%;
            text-align: center; color: red; font-size: 60px; font-weight: bold;
            text-shadow: 4px 4px 0 #000; display: none; pointer-events: none;
            animation: blink 0.2s infinite alternate;
        }
        @keyframes blink { from {opacity:1;} to {opacity:0.5;} }

        #overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; display: none;
        }
        #overlay h1 { font-size: 60px; margin: 0; text-transform: uppercase; letter-spacing: 5px; }
        #restart-btn {
            margin-top: 30px; padding: 15px 50px; font-size: 24px; cursor: pointer;
            background: #fff; color: #000; border: none; font-weight: bold; border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="money-display">MONEY: $0</div>
        
        <div class="btn" id="btn-soldier" onclick="spawnPlayerUnit('soldier')">
            <div class="name">SOLDIER</div>
            <div class="cost">$50</div>
        </div>
        
        <div class="btn" id="btn-tank" onclick="spawnPlayerUnit('tank')">
            <div class="name">TANK</div>
            <div class="cost">$200</div>
        </div>

        <div class="btn" id="btn-sniper" onclick="spawnPlayerUnit('sniper')">
            <div class="name">SNIPER</div>
            <div class="cost">$350</div>
        </div>

        <div class="btn" id="btn-titan" onclick="spawnPlayerUnit('titan')">
            <div class="name">TITAN</div>
            <div class="cost">$500</div>
        </div>

        <div style="border-left: 2px solid #666; height: 60px; margin: 0 10px;"></div>

        <div class="btn" id="btn-upgrade" onclick="upgradeWallet()">
            <div class="name">UPGRADE</div>
            <div class="cost" id="upg-cost">$500</div>
        </div>
    </div>

    <div id="boss-warning">WARNING: BOSS APPROACHING!</div>

    <div id="overlay">
        <h1 id="result-text">VICTORY</h1>
        <button id="restart-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- ユニット設定 ---
        // Overlord(敵ボス): HP 8000, Atk 200
        // Titan(味方ボス): HP 6000 (3/4), Atk 150 (3/4)
        const UNIT_TYPES = {
            soldier:  { cost: 50,  hp: 60,   dmg: 12,  range: 40,  speed: 2,   reload: 40,  bounty: 30,  color: '#33ff33', w: 10, h: 20 },
            tank:     { cost: 200, hp: 450,  dmg: 45,  range: 70,  speed: 1,   reload: 100, bounty: 150, color: '#3366ff', w: 40, h: 30 },
            sniper:   { cost: 350, hp: 50,   dmg: 90,  range: 280, speed: 1.5, reload: 120, bounty: 200, color: '#ff33ff', w: 10, h: 25 },
            titan:    { cost: 500, hp: 6000, dmg: 150, range: 60,  speed: 0.8, reload: 80,  bounty: 500, color: '#ddaa00', w: 60, h: 80 }, // 味方ボス
            overlord: { cost: 0,   hp: 8000, dmg: 200, range: 250, speed: 0.6, reload: 90,  bounty: 5000,color: '#222222', w: 80, h: 100 } // 敵ラスボス
        };

        let gameState = 'playing';
        let frame = 0;
        let money = 800; // 初期資金さらにアップ
        let moneyRate = 1; 
        let upgradeCost = 500;
        
        const GROUND_Y = window.innerHeight - 180;
        
        let units = [];
        let particles = [];
        let projectiles = [];
        let floatingTexts = [];
        
        // ラスボス管理フラグ
        let bossSpawned = false;

        const basePlayer = { x: 50, hp: 5000, maxHp: 5000, team: 'player', color: '#00ccff', w:60 };
        const baseEnemy = { x: window.innerWidth - 100, hp: 10000, maxHp: 10000, team: 'enemy', color: '#ff3333', w:60 };

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            baseEnemy.x = canvas.width - 100;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- クラス定義 ---

        class Unit {
            constructor(type, team) {
                const data = UNIT_TYPES[type];
                this.type = type;
                this.team = team;
                
                // 味方強化補正 (ボス以外)
                let buff = (team === 'player' && type !== 'titan') ? 1.3 : 1.0;
                
                this.maxHp = data.hp * buff;
                this.hp = this.maxHp;
                this.dmg = data.dmg * buff;
                
                this.range = data.range;
                this.speed = data.speed;
                this.reloadTime = data.reload;
                this.color = data.color;
                this.w = data.w;
                this.h = data.h;
                this.bounty = data.bounty;

                this.cooldown = 0;
                this.state = 'move';
                this.dead = false;

                // スピン攻撃用
                this.spinCooldown = 0;
                this.isSpinning = false;

                if (team === 'player') {
                    this.x = basePlayer.x + 60;
                    this.vx = this.speed;
                } else {
                    this.x = baseEnemy.x - 60;
                    this.vx = -this.speed;
                }
                this.y = GROUND_Y - this.h;
            }

            update() {
                if(this.dead) return;

                // 索敵
                let target = null;
                let minDist = 9999;
                const enemyTeam = (this.team === 'player') ? 'enemy' : 'player';

                // 一番近い敵を探す
                for(let u of units) {
                    if (u.team === enemyTeam && !u.dead) {
                        const dist = Math.abs(u.x - this.x);
                        if (dist < minDist) {
                            minDist = dist;
                            target = u;
                        }
                    }
                }

                // 基地判定
                const baseTarget = (this.team === 'player') ? baseEnemy : basePlayer;
                const baseDist = Math.abs(baseTarget.x - this.x);
                if (baseDist < minDist) {
                    minDist = baseDist;
                    target = baseTarget;
                    target.isBase = true;
                }

                // 行動 AI
                if (target) {
                    // ★ ラスボス専用AI: 近くに敵がいれば回転斬り、遠ければ魔法弾
                    if (this.type === 'overlord') {
                        if (minDist <= 120 && this.spinCooldown <= 0) {
                            // 近接範囲内なら回転攻撃発動
                            this.doSpinAttack();
                            this.cooldown = 60; // 硬直
                        } else if (minDist <= this.range && this.cooldown <= 0) {
                            // 遠距離攻撃
                            this.attack(target);
                            this.cooldown = this.reloadTime;
                        } else {
                            // クールダウン中 or 射程外
                            if (minDist > this.range) {
                                this.x += this.vx;
                                this.state = 'move';
                            }
                        }
                        this.spinCooldown--;
                    }
                    // 通常ユニットAI
                    else if (minDist <= this.range) {
                        this.state = 'attack';
                        this.cooldown--;
                        if (this.cooldown <= 0) {
                            this.attack(target);
                            this.cooldown = this.reloadTime;
                        }
                    } else {
                        this.state = 'move';
                        this.x += this.vx;
                        this.cooldown = Math.max(0, this.cooldown - 1);
                    }
                }
            }

            // 回転攻撃（周囲の敵全員にダメージ）
            doSpinAttack() {
                this.isSpinning = true;
                this.spinCooldown = 200; // 次の回転まで時間かかる
                
                // エフェクト
                spawnParticles(this.x, this.y + this.h/2, 20, '#purple');
                spawnFloatingText(this.x, this.y - 50, "SPIN SLASH!!", "#ff0000");

                // 判定：範囲150以内の敵すべて
                const enemyTeam = (this.team === 'player') ? 'enemy' : 'player';
                units.forEach(u => {
                    if (u.team === enemyTeam && !u.dead) {
                        if (Math.abs(u.x - this.x) < 150) {
                            u.takeDamage(this.dmg * 1.5, this.team); // ダメージ1.5倍
                            spawnParticles(u.x, u.y, 5, 'red');
                        }
                    }
                });
                
                setTimeout(() => { this.isSpinning = false; }, 500);
            }

            attack(target) {
                // オーバーロードの弾はデカい
                let size = (this.type === 'overlord' || this.type === 'titan') ? 10 : 3;
                let color = (this.type === 'overlord') ? '#8800ff' : '#ffff00';
                
                projectiles.push(new Projectile(this.x, this.y + this.h/2, target, this.dmg, this.team, size, color));
            }

            takeDamage(amount, attackerTeam) {
                this.hp -= amount;
                spawnParticles(this.x, this.y + this.h/2, 1, '#fff');
                
                if (this.hp <= 0 && !this.dead) {
                    this.dead = true;
                    // ボス撃破演出
                    if (this.type === 'overlord') {
                         spawnFloatingText(this.x, this.y-100, "BOSS DEFEATED!", "#gold");
                         spawnParticles(this.x, this.y, 100, 'gold');
                    }
                    if (this.team === 'enemy' && attackerTeam === 'player') {
                        money += this.bounty;
                        spawnFloatingText(this.x, this.y - 20, "+$" + this.bounty, '#ffff00');
                    }
                }
            }

            draw() {
                // スピン中の演出
                if (this.isSpinning) {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y + this.h/2, 120, 0, Math.PI*2);
                    ctx.strokeStyle = `rgba(255, 0, 0, ${Math.random()})`;
                    ctx.lineWidth = 10;
                    ctx.stroke();
                }

                ctx.fillStyle = (this.team === 'enemy') ? '#ff5555' : this.color;
                
                // オーバーロード（ラスボス）の外見
                if (this.type === 'overlord') {
                    ctx.fillStyle = '#220033'; // 闇の色
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                    // ツノ
                    ctx.fillStyle = '#aa0000';
                    ctx.beginPath();
                    ctx.moveTo(this.x - 20, this.y); ctx.lineTo(this.x - 30, this.y - 30); ctx.lineTo(this.x - 10, this.y);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.moveTo(this.x + 20, this.y); ctx.lineTo(this.x + 30, this.y - 30); ctx.lineTo(this.x + 10, this.y);
                    ctx.fill();
                    // 目
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - 20, this.y + 20, 15, 5);
                    ctx.fillRect(this.x + 5, this.y + 20, 15, 5);

                } 
                // タイタン（味方ボス）の外見
                else if (this.type === 'titan') {
                    ctx.fillStyle = '#ddaa00'; // 金色
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                    // バイザー
                    ctx.fillStyle = '#00ffff';
                    ctx.fillRect(this.x - 20, this.y + 15, 40, 10);
                }
                // その他
                else if (this.type === 'tank') {
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                    ctx.fillStyle = '#222';
                    ctx.fillRect(this.x + (this.team==='player'?5:-25), this.y-5, 20, 5);
                } else {
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                    ctx.fillStyle = '#000';
                    ctx.fillRect(this.x, this.y + 8, (this.team==='player'?15:-15), 2);
                }

                // HPバー (ボスは大きく)
                const isBoss = (this.type === 'overlord' || this.type === 'titan');
                const barW = isBoss ? 80 : 20;
                const barH = isBoss ? 8 : 4;
                const barY = isBoss ? 15 : 8;

                const pct = Math.max(0, this.hp / this.maxHp);
                ctx.fillStyle = '#444';
                ctx.fillRect(this.x - barW/2, this.y - barY, barW, barH);
                ctx.fillStyle = (this.team === 'player') ? '#00ff00' : '#ff0000';
                ctx.fillRect(this.x - barW/2, this.y - barY, barW * pct, barH);
            }
        }

        class Projectile {
            constructor(x, y, target, dmg, team, size, color) {
                this.x = x; this.y = y; this.target = target;
                this.dmg = dmg; this.team = team; this.speed = 10; this.active = true;
                this.size = size || 3;
                this.color = color || '#ffff00';
                
                const tx = (target.isBase) ? target.x : target.x;
                const ty = (target.isBase) ? (GROUND_Y - 40) : (target.y + 10);
                const dx = tx - x; const dy = ty - y;
                const d = Math.sqrt(dx*dx + dy*dy);
                this.vx = (dx/d) * this.speed; this.vy = (dy/d) * this.speed;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                let hit = false;
                if (this.target.isBase) {
                    if (Math.abs(this.x - this.target.x) < 50) { this.target.hp -= this.dmg; hit = true; }
                } else if (!this.target.dead) {
                    if (Math.abs(this.x - this.target.x) < (20+this.target.w/2) && Math.abs(this.y - (this.target.y + this.target.h/2)) < (20+this.target.h/2)) {
                        this.target.takeDamage(this.dmg, this.team); hit = true;
                    }
                } else { if (Math.abs(this.x - this.target.x) < 10) this.active = false; }
                if (hit) { this.active = false; spawnParticles(this.x, this.y, 4, this.color); }
                if (this.x < 0 || this.x > canvas.width) this.active = false;
            }
            draw() { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI*2); ctx.fill(); }
        }

        class FloatingText {
            constructor(x, y, text, color) { this.x=x; this.y=y; this.text=text; this.color=color; this.life=1.0; this.vy=-1.5; }
            update() { this.y+=this.vy; this.life-=0.02; }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color;
                ctx.font = "bold 20px Arial"; ctx.strokeStyle="black"; ctx.lineWidth=3;
                ctx.strokeText(this.text, this.x, this.y); ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }
        }
        class Particle {
            constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.vx=(Math.random()-0.5)*6; this.vy=(Math.random()-0.5)*6; this.life=1.0; }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; }
            draw() { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle=this.color; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha=1.0; }
        }
        function spawnParticles(x, y, c, col) { for(let i=0; i<c; i++) particles.push(new Particle(x,y,col)); }
        function spawnFloatingText(x, y, txt, col) { floatingTexts.push(new FloatingText(x, y, txt, col)); }

        function spawnPlayerUnit(type) {
            if (gameState !== 'playing') return;
            const cost = UNIT_TYPES[type].cost;
            if (money >= cost) {
                money -= cost;
                units.push(new Unit(type, 'player'));
            }
        }

        function upgradeWallet() {
            if (money >= upgradeCost) {
                money -= upgradeCost;
                moneyRate += 1; 
                upgradeCost += 500;
                document.getElementById('upg-cost').innerText = "$" + upgradeCost;
                spawnFloatingText(basePlayer.x, basePlayer.y - 100, "LEVEL UP!!", "#00ffff");
            }
        }

        // --- ゲームループ制御 ---
        
        // ラスボス出現チェック
        function checkBossSpawn() {
            if (bossSpawned) return;
            
            // マップの3/4 (75%) ライン
            const triggerLine = canvas.width * 0.75;
            
            // 誰か一人でもラインを超えたか？
            let reached = units.some(u => u.team === 'player' && u.x > triggerLine);
            
            if (reached) {
                spawnBoss();
            }
        }

        function spawnBoss() {
            bossSpawned = true;
            // 警告表示
            const w = document.getElementById('boss-warning');
            w.style.display = 'block';
            setTimeout(() => w.style.display = 'none', 4000);
            
            // ボス召喚
            units.push(new Unit('overlord', 'enemy'));
        }

        let enemyTimer = 0;
        function updateEnemyAI() {
            if(gameState !== 'playing') return;
            enemyTimer++;
            
            // 普段の敵湧き（ゆっくり）
            let spawnInterval = 250 - (frame / 500); 
            if(spawnInterval < 100) spawnInterval = 100;

            if (enemyTimer > spawnInterval) {
                const r = Math.random();
                let type = 'soldier';
                if (r < 0.2 && frame > 1000) type = 'tank';
                if (r < 0.05 && frame > 2000) type = 'sniper';
                
                // ボスが出現しているときは雑魚がボスを守るように湧く
                if (bossSpawned && Math.random() < 0.5) type = 'tank';

                units.push(new Unit(type, 'enemy'));
                enemyTimer = 0;
            }
        }

        function update() {
            if (gameState !== 'playing') return;
            frame++;

            if (frame % 6 === 0) money += moneyRate;
            document.getElementById('money-display').innerText = "MONEY: $" + Math.floor(money);
            
            // ボタン制御
            ['soldier', 'tank', 'sniper', 'titan'].forEach(type => {
                const btn = document.getElementById('btn-'+type);
                if (money >= UNIT_TYPES[type].cost) btn.classList.remove('disabled');
                else btn.classList.add('disabled');
            });
            const upgBtn = document.getElementById('btn-upgrade');
            if (money >= upgradeCost) upgBtn.classList.remove('disabled');
            else upgBtn.classList.add('disabled');

            updateEnemyAI();
            checkBossSpawn(); // ボスチェック

            units.forEach(u => u.update());
            units = units.filter(u => !u.dead);

            projectiles.forEach(p => p.update());
            projectiles = projectiles.filter(p => p.active);

            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            floatingTexts.forEach(t => t.update());
            floatingTexts = floatingTexts.filter(t => t.life > 0);

            if (basePlayer.hp <= 0) endGame(false);
            if (baseEnemy.hp <= 0) endGame(true);
        }

        function draw() {
            // 背景
            const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
            // ボス出現時は空が暗くなる演出
            if (bossSpawned) {
                grd.addColorStop(0, "#330000");
                grd.addColorStop(1, "#552222");
            } else {
                grd.addColorStop(0, "#00BFFF");
                grd.addColorStop(1, "#87CEEB");
            }
            ctx.fillStyle = grd;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#2d8f2d';
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

            drawBase(basePlayer);
            drawBase(baseEnemy);
            
            // トリガーライン（3/4）を目安として描画
            if (!bossSpawned) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.setLineDash([10, 10]);
                ctx.beginPath();
                ctx.moveTo(canvas.width * 0.75, 0);
                ctx.lineTo(canvas.width * 0.75, canvas.height);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.fillText("DANGER ZONE", canvas.width * 0.75 - 50, 50);
            }

            units.forEach(u => u.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());
            floatingTexts.forEach(t => t.draw());

            requestAnimationFrame(() => {
                update();
                draw();
            });
        }

        function drawBase(base) {
            ctx.fillStyle = base.color;
            ctx.beginPath();
            ctx.arc(base.x, GROUND_Y, 70, Math.PI, 0);
            ctx.fill();
            const pct = Math.max(0, base.hp / base.maxHp);
            ctx.fillStyle = '#000';
            ctx.fillRect(base.x - 50, GROUND_Y - 110, 100, 12);
            ctx.fillStyle = (pct > 0.3) ? '#00ff00' : 'red';
            ctx.fillRect(base.x - 50, GROUND_Y - 110, 100 * pct, 12);
            ctx.strokeStyle = '#fff';
            ctx.strokeRect(base.x - 50, GROUND_Y - 110, 100, 12);
        }

        function endGame(win) {
            gameState = (win) ? 'win' : 'lose';
            const ov = document.getElementById('overlay');
            const txt = document.getElementById('result-text');
            ov.style.display = 'flex';
            if (win) {
                txt.innerText = "VICTORY!!";
                txt.style.color = "#00ffcc";
            } else {
                txt.innerText = "DEFEAT...";
                txt.style.color = "#ff3333";
            }
        }

        draw();
    </script>
</body>
</html>
