<script>
(() => {

  // ====== 元の設定そのまま ======
  const size = 8;
  const colorPalette = ["#f94144","#f3722c","#f9844a","#f9c74f","#90be6d","#43aa8b","#577590","#7400b8"];

  const threeByThree = [
    [1,1,1],
    [1,1,1],
    [1,1,1]
  ];

  const twoByThree = [
    [1,1,1],
    [1,1,1]
  ];

  const baseShapes = [
    [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]],
    [[1],[1]], [[1],[1],[1]],
    [[1,1],[1,1]], [[1,0],[1,1]], [[1,1,1],[0,1,0]]
  ];

  const BEAM_WIDTH = 120;
  const SEARCH_DEPTH = 3;
  const TIME_LIMIT_MS = 700;
  const ALLCLEAR_BONUS = 120000;

  let comboCount = 0;
  const LINE_POINT = 10;
  const SIMULTANEOUS_BONUS_STEP = 15;
  const COMBO_BASE = 15;
  const ALLCLEAR_UI_BONUS = 500;

  let board = [];
  let pieces = [];
  let score = 0;
  let mode = "manual";
  let aiBusy = false;
  let lastPlan = null;
  let allClearStreak = 0;

  const boardEl = document.getElementById('board');
  const piecesEl = document.getElementById('pieces');
  const scoreEl = document.getElementById('score');
  const predictionInfo = document.getElementById('predictionInfo');
  const streakLabel = document.getElementById('streakLabel');
  const aiLabel = document.getElementById('aiLabel');

  const deepCopyGrid = g => g.map(r => r.slice());
  const randColor = () => colorPalette[Math.floor(Math.random()*colorPalette.length)];
  const countPieceCells = p => p.shape.flat().filter(v=>v).length;
  const shapesEqual = (a,b)=>JSON.stringify(a)===JSON.stringify(b);
  const isThreeByThree = p => p.shape.length===3 && p.shape[0].length===3 && p.shape.flat().every(v=>v===1);

  // ====== 追加：置ける保証関数 ======
  function hasAnyPlacement(piece, grid){
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        if(canPlace(piece.shape,y,x,grid)) return true;
      }
    }
    return false;
  }

  function randomBaseShape(){
    return baseShapes[Math.floor(Math.random()*baseShapes.length)];
  }

  function randomNon3x3Shape(){
    const list = baseShapes.filter(s=>!shapesEqual(s,threeByThree));
    return list[Math.floor(Math.random()*list.length)];
  }

  // ====== ★改良 generateHand（AIそのまま） ======
  function generateHand(){
    pieces = [];
    const occ = board.map(r=>r.map(v=>v?1:0));
    let safety = 1000;

    while(pieces.length < 3 && safety > 0){
      safety--;

      const count3 = pieces.filter(isThreeByThree).length;
      let shape;

      if(count3 === 0){
        shape = Math.random()<0.12 ? threeByThree : randomBaseShape();
      } else if(count3 === 1){
        shape = Math.random()<0.5 ? threeByThree : randomNon3x3Shape();
      } else {
        shape = Math.random()<0.7 ? twoByThree : randomNon3x3Shape();
      }

      const candidate = { shape: shape, color: randColor() };

      // ★必ず置けるものだけ採用
      if(hasAnyPlacement(candidate, occ)){
        pieces.push(candidate);
      }
    }

    // 本当に盤面が詰んでいる場合のみゲーム終了
    if(pieces.length < 3){
      alert("GAME OVER");
    }
  }

  // ====== 以下は元コードそのまま（AI含む） ======

  function canPlace(shape, y, x, grid){
    for(let dy=0; dy<shape.length; dy++){
      for(let dx=0; dx<shape[0].length; dx++){
        if(shape[dy][dx]){
          if(y+dy < 0 || x+dx < 0 || y+dy >= size || x+dx >= size) return false;
          if(grid[y+dy][x+dx]) return false;
        }
      }
    }
    return true;
  }

  function simulatePlaceNoColor(grid, piece, y, x){
    const g = deepCopyGrid(grid);
    for(let dy=0; dy<piece.shape.length; dy++){
      for(let dx=0; dx<piece.shape[0].length; dx++){
        if(piece.shape[dy][dx]) g[y+dy][x+dx] = 1;
      }
    }
    let lines = 0;
    for(let r=0;r<size;r++){
      if(g[r].every(v=>v)){ lines++; g[r].fill(0); }
    }
    for(let c=0;c<size;c++){
      if(g.map(row=>row[c]).every(v=>v)){ lines++; for(let r=0;r<size;r++) g[r][c]=0; }
    }
    return { grid: g, lines };
  }

  function placeAndScoreAtomic(piece, y, x){
    const occBefore = board.map(r=>r.map(v=>v?1:0));
    const sim = simulatePlaceNoColor(occBefore, piece, y, x);
    const lines = sim.lines;

    let gained = countPieceCells(piece);

    if(lines>0){
      gained += lines * LINE_POINT;
      if(lines>=2) gained += (lines-1)*SIMULTANEOUS_BONUS_STEP;
      comboCount++;
      gained += COMBO_BASE + (comboCount-1)*10;
    } else {
      comboCount = 0;
    }

    for(let dy=0; dy<piece.shape.length; dy++){
      for(let dx=0; dx<piece.shape[0].length; dx++){
        if(piece.shape[dy][dx]) board[y+dy][x+dx] = piece.color;
      }
    }

    for(let r=0;r<size;r++) if(board[r].every(v=>v)) board[r].fill(0);
    for(let c=0;c<size;c++) if(board.map(row=>row[c]).every(v=>v)) for(let r=0;r<size;r++) board[r][c]=0;

    if(board.flat().filter(Boolean).length===0){
      gained += ALLCLEAR_UI_BONUS;
      allClearStreak++;
    } else {
      allClearStreak=0;
    }

    score += Math.floor(gained);
  }

  function drawBoard(){
    boardEl.innerHTML='';
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const c=document.createElement('div');
        c.className='cell';
        if(board[y][x]){
          const b=document.createElement('div');
          b.className='piece-block';
          b.style.background=board[y][x];
          c.appendChild(b);
        }
        boardEl.appendChild(c);
      }
    }
  }

  function drawHand(){
    piecesEl.innerHTML='';
    pieces.forEach((p,i)=>{
      const btn=document.createElement('button');
      btn.textContent='P'+(i+1);
      btn.onclick=()=>{
        for(let y=0;y<size;y++){
          for(let x=0;x<size;x++){
            if(canPlace(p.shape,y,x,board)){
              placeAndScoreAtomic(p,y,x);
              pieces.splice(i,1);
              if(pieces.length===0) generateHand();
              drawAll();
              return;
            }
          }
        }
      };
      piecesEl.appendChild(btn);
    });
  }

  function drawAll(){
    drawBoard();
    drawHand();
    scoreEl.innerText='SCORE: '+score;
    streakLabel.innerText='Combo: '+comboCount;
  }

  function init(){
    board = Array(size).fill().map(()=>Array(size).fill(0));
    score=0;
    comboCount=0;
    generateHand();
    drawAll();
  }

  document.getElementById('startBtn').onclick=init;
  document.getElementById('manualBtn').onclick=()=>mode='manual';

  init();

})();
</script>
