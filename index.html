<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>APEX STYLE: FINAL VERSION</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* ロード画面 */
        #loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #ff3333; z-index: 9999;
            display: flex; justify-content: center; align-items: center;
            font-size: 30px; font-weight: bold; letter-spacing: 5px;
        }

        /* HUDレイヤー */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }

        /* 照準 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; align-items: center; justify-content: center;
        }
        .ch-circle { 
            width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%; 
            transition: all 0.1s;
        }

        /* 左下：ステータス */
        #player-status {
            position: absolute; bottom: 30px; left: 40px;
            display: flex; flex-direction: column; gap: 5px;
            transform: skewX(-15deg);
        }
        .bar-container {
            width: 250px; height: 14px; background: rgba(20, 20, 30, 0.6);
            border: 1px solid #555; position: relative;
        }
        #shield-fill { width: 100%; height: 100%; background: #00bfff; box-shadow: 0 0 10px #00bfff; transition: width 0.1s; }
        #health-fill { width: 100%; height: 100%; background: #fff; transition: width 0.1s; }

        /* 右下：武器 */
        #weapon-status {
            position: absolute; bottom: 30px; right: 40px;
            text-align: right; color: white; transform: skewX(-15deg);
        }
        #ammo-count { font-size: 50px; font-weight: 900; line-height: 1; text-shadow: 0 0 10px #000; }
        #weapon-name { font-size: 16px; color: #ff9900; font-weight: bold; }

        /* ダメージ数字 */
        #damage-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; overflow: hidden;}
        .dmg-num {
            position: absolute; font-family: 'Arial Black', sans-serif; font-weight: 900;
            font-size: 24px; text-shadow: 2px 2px 0 #000;
            animation: floatUp 0.6s ease-out forwards;
        }
        @keyframes floatUp { to { opacity: 0; transform: translateY(-50px) scale(1.1); } }
        .dmg-shield { color: #00bfff; -webkit-text-stroke: 1px #005f7f; }
        .dmg-health { color: #ffffff; -webkit-text-stroke: 1px #555; }

        /* スタート画面 */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,15,0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 1000; cursor: pointer; display: none;
        }
        h1 { font-size: 60px; margin: 0; font-style: italic; text-shadow: 0 0 20px #ff3333; }
        #start-msg { font-size: 24px; margin-top: 20px; background: #ff3333; padding: 10px 30px; transform: skewX(-15deg); }
    </style>
</head>
<body>
    <div id="loading-screen">LOADING RESOURCES...</div>

    <div id="ui-layer">
        <div id="crosshair"><div class="ch-circle" id="ch-circle"></div></div>
        <div id="player-status">
            <div style="color:#fff; font-weight:bold; font-size:18px;">LEGEND</div>
            <div class="bar-container"><div id="shield-fill"></div></div>
            <div class="bar-container"><div id="health-fill"></div></div>
        </div>
        <div id="weapon-status">
            <div id="weapon-name">R-301</div>
            <div id="ammo-count">28</div>
        </div>
    </div>
    <div id="damage-overlay"></div>

    <div id="blocker">
        <h1>BATTLE READY</h1>
        <div id="start-msg">CLICK TO START</div>
        <p style="margin-top:20px; color:#aaa;">WASD:移動 | SHIFT:走る | C:スライディング | SPACE:ジャンプ | R:リロード | クリック:撃つ</p>
    </div>

    <script src="https://unpkg.com/three@0.126.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // ロードチェック
        window.addEventListener('load', () => {
            if (typeof THREE === 'undefined') {
                alert("エラー: ゲームエンジンを読み込めませんでした。インターネット接続を確認してください。");
                return;
            }
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('blocker').style.display = 'flex';
            init();
            animate();
        });

        // --- 設定 ---
        const MOVE_SPEED = 12;
        const SPRINT_SPEED = 20;
        const SLIDE_SPEED = 35;
        const MAG_SIZE = 28;

        let camera, scene, renderer, controls;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        let moveF=false, moveB=false, moveL=false, moveR=false;
        let isSprint=false, isCrouch=false, canJump=false, isSlide=false;
        let slideVel = 0;

        let ammo = MAG_SIZE;
        let shield = 100, hp = 100;
        let isReloading = false;
        
        const enemies = [];
        const bullets = [];
        const colliders = []; // 地面や壁

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.y = 1.7;

            // ライト
            scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.8));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // コントロール
            controls = new THREE.PointerLockControls(camera, document.body);
            const blocker = document.getElementById('blocker');
            blocker.addEventListener('click', () => controls.lock());
            
            controls.addEventListener('lock', () => {
                blocker.style.display = 'none';
                document.getElementById('ui-layer').style.display = 'block';
            });
            controls.addEventListener('unlock', () => {
                blocker.style.display = 'flex';
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('start-msg').innerText = "CLICK TO RESUME";
            });
            scene.add(controls.getObject());

            // マップ作成
            createMap();
            // 敵作成
            for(let i=0; i<4; i++) spawnEnemy();

            // レンダラー
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // イベント
            document.addEventListener('keydown', onKey);
            document.addEventListener('keyup', onKey);
            document.addEventListener('mousedown', (e) => { if(controls.isLocked && e.button===0) shoot(); });
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth/window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createMap() {
            // 地面
            const ground = new THREE.Mesh(
                new THREE.PlaneGeometry(500, 500),
                new THREE.MeshPhongMaterial({ color: 0xccaa88 })
            );
            ground.rotation.x = -Math.PI/2;
            scene.add(ground);
            colliders.push(ground);

            // 岩/遮蔽物
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            const boxMat = new THREE.MeshPhongMaterial({ color: 0x666666 });
            for(let i=0; i<30; i++) {
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.set((Math.random()-0.5)*100, 2, (Math.random()-0.5)*100 - 20);
                box.scale.set(5+Math.random()*10, 4+Math.random()*6, 5+Math.random()*10);
                scene.add(box);
                colliders.push(box);
            }
        }

        function spawnEnemy() {
            const bot = new THREE.Group();
            // 赤い体
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8), new THREE.MeshPhongMaterial({color:0xaa2222}));
            body.position.y = 0.9;
            bot.add(body);
            // 頭
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshPhongMaterial({color:0x550000}));
            head.position.y = 2.0;
            bot.add(head);

            bot.position.set((Math.random()-0.5)*60, 0, (Math.random()-0.5)*40 - 30);
            scene.add(bot);
            
            enemies.push({ mesh: bot, hp: 100, shield: 50, dir: 1, lastMove: 0 });
        }

        function onKey(e) {
            const isDown = e.type === 'keydown';
            switch(e.code) {
                case 'KeyW': moveF = isDown; break;
                case 'KeyA': moveL = isDown; break;
                case 'KeyS': moveB = isDown; break;
                case 'KeyD': moveR = isDown; break;
                case 'ShiftLeft': isSprint = isDown; break;
                case 'KeyR': if(isDown) reload(); break;
                case 'Space': if(isDown && canJump) { velocity.y = 15; canJump = false; } break;
                case 'KeyC': 
                    if(isDown) {
                        if(isSprint && moveF && !isSlide) { isSlide = true; slideVel = SLIDE_SPEED; }
                        isCrouch = true; camera.position.y = 0.9;
                    } else {
                        isCrouch = false; isSlide = false; camera.position.y = 1.7;
                    }
                    break;
            }
        }

        function shoot() {
            if(isReloading || ammo <= 0) { reload(); return; }
            ammo--;
            updateHUD();

            // 弾（レイキャスト）
            const ray = new THREE.Raycaster();
            ray.setFromCamera(new THREE.Vector2(), camera);
            
            // クロスヘア跳ね上がり演出
            const ch = document.getElementById('ch-circle');
            ch.style.width = '30px'; ch.style.height = '30px';
            setTimeout(()=> { ch.style.width='20px'; ch.style.height='20px'; }, 100);

            // 判定
            const hits = ray.intersectObjects(scene.children, true);
            let hitEnemy = false;
            
            for(let hit of hits) {
                // 親を探して敵判定
                let target = hit.object;
                while(target.parent && target.parent.type !== 'Scene') target = target.parent;
                
                const en = enemies.find(e => e.mesh === target);
                if(en && en.hp > 0) {
                    const isHead = hit.point.y > en.mesh.position.y + 1.6;
                    let dmg = isHead ? 22 : 11;
                    let type = 'health';
                    
                    if(en.shield > 0) {
                        en.shield -= dmg; type = 'shield';
                        if(en.shield < 0) { en.hp += en.shield; en.shield = 0; dmgText(hit.point, "割れた!", "shield"); }
                    } else {
                        en.hp -= dmg; type = isHead ? 'head' : 'health';
                    }
                    dmgText(hit.point, dmg, type);

                    if(en.hp <= 0) {
                        en.mesh.visible = false;
                        setTimeout(() => { en.hp=100; en.shield=50; en.mesh.visible=true; }, 3000); // リスポーン
                    }
                    hitEnemy = true;
                    break; 
                }
                if(!hitEnemy && hit.distance < 100) break; // 壁に当たった
            }
        }

        function dmgText(pos, txt, type) {
            const div = document.createElement('div');
            div.className = `dmg-num dmg-${type}`;
            div.innerText = txt;
            
            // 3D位置を画面位置へ
            const vec = pos.clone().project(camera);
            if(vec.z > 1) return;
            const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-(vec.y * 0.5) + 0.5) * window.innerHeight;
            
            div.style.left = x + 'px'; div.style.top = y + 'px';
            document.getElementById('damage-overlay').appendChild(div);
            setTimeout(() => div.remove(), 600);
        }

        function reload() {
            if(isReloading) return;
            isReloading = true;
            document.getElementById('weapon-name').innerText = "RELOADING...";
            setTimeout(() => {
                ammo = MAG_SIZE; isReloading = false;
                document.getElementById('weapon-name').innerText = "R-301";
                updateHUD();
            }, 1500);
        }

        function updateHUD() {
            document.getElementById('ammo-count').innerText = ammo;
            document.getElementById('shield-fill').style.width = shield + "%";
            document.getElementById('health-fill').style.width = hp + "%";
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!controls.isLocked) { prevTime = performance.now(); return; }

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            // 物理演算(簡易)
            velocity.x -= velocity.x * 10 * delta;
            velocity.z -= velocity.z * 10 * delta;
            velocity.y -= 30 * delta; // 重力

            direction.z = Number(moveF) - Number(moveB);
            direction.x = Number(moveR) - Number(moveL);
            direction.normalize();

            let spd = isSprint ? SPRINT_SPEED : MOVE_SPEED;
            if(isSlide) {
                spd = slideVel; slideVel -= 20 * delta;
                if(slideVel < 5) isSlide = false;
            } else if(isCrouch) spd = MOVE_SPEED * 0.5;

            if(moveF || moveB) velocity.z -= direction.z * spd * 10 * delta;
            if(moveL || moveR) velocity.x -= direction.x * spd * 10 * delta;

            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);
            controls.getObject().position.y += velocity.y * delta;

            // 接地判定
            const h = isCrouch ? 0.9 : 1.7;
            if(controls.getObject().position.y < h) {
                velocity.y = 0;
                controls.getObject().position.y = h;
                canJump = true;
            }

            // 敵の動き
            enemies.forEach(en => {
                if(en.hp <= 0) return;
                en.mesh.lookAt(camera.position.x, en.mesh.position.y, camera.position.z);
                if(time - en.lastMove > 1500) { en.dir *= -1; en.lastMove = time; }
                en.mesh.translateX(en.dir * 4 * delta);
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
