<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>BROWSER LEGENDS: FIXED</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #000; user-select: none; }
        
        /* --- HUD„É¨„Ç§„É§„Éº --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* ÁÖßÊ∫ñ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: flex; align-items: center; justify-content: center;
        }
        .ch-dot { width: 4px; height: 4px; background: #fff; border-radius: 50%; box-shadow: 0 0 4px #fff; }
        .ch-circle { 
            position: absolute; width: 20px; height: 20px; 
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; 
            transition: width 0.1s, height 0.1s;
        }

        /* Â∑¶‰∏ãÔºö„Éò„É´„ÇπÔºÜ„Ç∑„Éº„É´„Éâ (APEXÈ¢®) */
        #player-status {
            position: absolute; bottom: 30px; left: 40px;
            display: flex; flex-direction: column; gap: 5px;
            transform: skewX(-15deg);
        }
        .bar-row { display: flex; align-items: center; gap: 5px; }
        .bar-container {
            width: 250px; height: 14px; background: rgba(20, 20, 30, 0.6);
            border: 1px solid #555; position: relative;
        }
        #shield-fill { width: 100%; height: 100%; background: #00bfff; box-shadow: 0 0 10px #00bfff; transition: width 0.1s; }
        #health-fill { width: 100%; height: 100%; background: #fff; transition: width 0.1s; }
        .player-name { color: #fff; font-size: 18px; font-weight: 800; transform: skewX(15deg); margin-bottom: 5px; text-shadow: 0 0 5px rgba(0,0,0,0.5); }

        /* Âè≥‰∏ãÔºöÊ≠¶Âô®ÔºÜÂºæËñ¨ */
        #weapon-status {
            position: absolute; bottom: 30px; right: 40px;
            text-align: right; color: white; transform: skewX(-15deg);
        }
        #ammo-count { font-size: 48px; font-weight: 900; line-height: 1; }
        #weapon-name { font-size: 16px; color: #ff9900; font-weight: bold; letter-spacing: 2px; }
        #mag-bar { width: 150px; height: 6px; background: #333; margin-left: auto; margin-top: 5px; }
        #mag-fill { width: 100%; height: 100%; background: #ff9900; }

        /* „ÉÄ„É°„Éº„Ç∏Ë°®Á§∫ */
        #damage-overlay { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; overflow: hidden;}
        .dmg-num {
            position: absolute; font-family: 'Arial Black', sans-serif; font-weight: 900;
            font-size: 24px; pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            animation: floatUp 0.8s ease-out forwards;
        }
        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }
        .dmg-shield { color: #00bfff; -webkit-text-stroke: 1px #005f7f; }
        .dmg-health { color: #ffffff; -webkit-text-stroke: 1px #555; }
        .dmg-head { color: #ffcc00; font-size: 32px; -webkit-text-stroke: 1px #884400; z-index: 100; }

        /* ÈÄöÁü•„Ç®„É™„Ç¢ */
        #kill-feed {
            position: absolute; top: 100px; right: 20px;
            display: flex; flex-direction: column; align-items: flex-end; gap: 5px;
        }
        .feed-item {
            background: rgba(0,0,0,0.7); color: white; padding: 5px 10px;
            border-left: 4px solid #ff3333; font-size: 14px;
            transform: skewX(-15deg);
        }

        /* „Çπ„Çø„Éº„ÉàÁîªÈù¢ */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,15,0.95);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; z-index: 999; cursor: pointer;
        }
        h1 { font-size: 60px; margin: 0; font-style: italic; letter-spacing: -2px; text-shadow: 0 0 20px #ff3333; text-align: center; }
        #start-btn {
            margin-top: 30px; padding: 20px 60px; font-size: 28px; font-weight: bold;
            background: #ff3333; color: white; border: 2px solid #fff; transform: skewX(-15deg);
            cursor: pointer; transition: 0.2s; box-shadow: 0 0 20px rgba(255, 50, 50, 0.5);
        }
        #start-btn:hover { background: #ff6666; transform: skewX(-15deg) scale(1.05); }
        .controls { margin-top: 30px; text-align: center; color: #aaa; font-size: 14px; line-height: 1.6; }
        .key { border: 1px solid #666; padding: 2px 6px; background: #222; font-weight: bold; color: #fff; margin: 0 2px; }
    </style>
</head>
<body>
    <div id="ui-layer">
        <div id="crosshair">
            <div class="ch-dot"></div>
            <div class="ch-circle" id="ch-circle"></div>
        </div>

        <div id="player-status">
            <div class="player-name">LEGEND</div>
            <div class="bar-row">
                <div class="bar-container"><div id="shield-fill"></div></div>
            </div>
            <div class="bar-row">
                <div class="bar-container"><div id="health-fill"></div></div>
            </div>
        </div>

        <div id="weapon-status">
            <div id="weapon-name">R-301 CARBINE</div>
            <div id="ammo-count">28</div>
            <div id="mag-bar"><div id="mag-fill"></div></div>
        </div>
        <div id="kill-feed"></div>
    </div>
    <div id="damage-overlay"></div>

    <div id="blocker">
        <h1>BROWSER LEGENDS</h1>
        <div id="start-btn">CLICK TO START</div>
        <div class="controls">
            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> ÁßªÂãï | <span class="key">SHIFT</span> „ÉÄ„ÉÉ„Ç∑„É•</p>
            <p><span class="key">C</span> „Çπ„É©„Ç§„Éá„Ç£„É≥„Ç∞ | <span class="key">SPACE</span> „Ç∏„É£„É≥„Éó</p>
            <p><span class="key">R</span> „É™„É≠„Éº„Éâ | <span class="key">Â∑¶„ÇØ„É™„ÉÉ„ÇØ</span> Â∞ÑÊíÉ</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

    <script>
        // --- Ë®≠ÂÆö (APEX„Éï„Ç£„Éº„É´) ---
        const MOVE_SPEED = 10;
        const SPRINT_SPEED = 18;
        const SLIDE_SPEED_INIT = 30;
        const JUMP_FORCE = 15;
        const GRAVITY = 35;
        const PLAYER_HEIGHT = 1.7;
        const CROUCH_HEIGHT = 0.9;
        
        const MAG_SIZE = 28;
        const FIRE_RATE = 80; // ÈÄ£Â∞ÑÈÄüÂ∫¶ms
        const RECOIL_AMOUNT = 0.002;

        // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
        let camera, scene, renderer, controls;
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        
        let moveForward=false, moveBackward=false, moveLeft=false, moveRight=false;
        let isSprinting=false, isCrouching=false, canJump=false, isSliding=false;
        let slideVelocity = 0;
        let isFiring = false;

        // „Ç≤„Éº„É†„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
        const enemies = [];
        const colliders = [];

        // „Çπ„ÉÜ„Éº„Çø„Çπ
        let hp = 100, shield = 100;
        let ammo = MAG_SIZE;
        let isReloading = false;
        let lastShotTime = 0;
        let currentRecoil = 0;

        // UIÂèñÂæó
        const uiShield = document.getElementById('shield-fill');
        const uiHealth = document.getElementById('health-fill');
        const uiAmmo = document.getElementById('ammo-count');
        const uiMag = document.getElementById('mag-fill');
        const damageOverlay = document.getElementById('damage-overlay');
        const crosshairCircle = document.getElementById('ch-circle');
        const blocker = document.getElementById('blocker');
        const startBtn = document.getElementById('start-btn');

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 150);

            camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.y = PLAYER_HEIGHT;

            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            scene.add(hemiLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // „Ç≥„É≥„Éà„É≠„Éº„É´Ë®≠ÂÆöÔºàr128„ÅÆ„Ç∞„É≠„Éº„Éê„É´ÁâàÔºâ
            controls = new THREE.PointerLockControls(camera, document.body);

            // „Çπ„Çø„Éº„Éà„Éú„Çø„É≥„ÅÆÂá¶ÁêÜ
            startBtn.addEventListener('click', function() {
                controls.lock();
            });
            // „Éñ„É≠„ÉÉ„Ç´„ÉºËá™‰Ωì„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶„ÇÇ„Çπ„Çø„Éº„Éà„Åß„Åç„Çã„Çà„ÅÜ„Å´„Åô„ÇãÔºà‰øùÈô∫Ôºâ
            blocker.addEventListener('click', function(e) {
                if(e.target !== startBtn) controls.lock();
            });

            controls.addEventListener('lock', function() {
                blocker.style.display = 'none';
            });
            controls.addEventListener('unlock', function() {
                blocker.style.display = 'flex';
                document.querySelector('h1').innerText = "PAUSED";
                startBtn.innerText = "RESUME";
            });

            scene.add(controls.getObject());

            // „Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', (e) => { if(controls.isLocked && e.button===0) isFiring = true; });
            document.addEventListener('mouseup', () => isFiring = false);
            window.addEventListener('resize', onWindowResize);

            createMap();

            // „É¨„É≥„ÉÄ„É©„Éº (RetinaÂØæÂøú„ÅßÈáç„Åè„Å™„Çâ„Å™„ÅÑ„Çà„ÅÜPixelRatio„ÅØ1„Å´Âõ∫ÂÆö)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(1); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // ÊïµÁîüÊàê
            for(let i=0; i<4; i++) spawnDummy(i);
        }

        function createMap() {
            // Âú∞Èù¢
            const groundGeo = new THREE.PlaneGeometry(1000, 1000);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0xccaa88, roughness: 0.9 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
            colliders.push(ground);

            // Â£Å„Å®ÈÅÆËîΩÁâ©
            const boxGeo = new THREE.BoxGeometry(1,1,1);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
            
            for(let i=0; i<30; i++) {
                const wall = new THREE.Mesh(boxGeo, boxMat);
                // „É©„É≥„ÉÄ„É†ÈÖçÁΩÆ
                const x = (Math.random()-0.5)*150;
                const z = (Math.random()-0.5)*150 - 20;
                const sy = 4 + Math.random()*6;
                wall.position.set(x, sy/2, z);
                wall.scale.set(5+Math.random()*10, sy, 5+Math.random()*10);
                wall.castShadow = true;
                scene.add(wall);
                colliders.push(wall);
            }
            
            // „Çπ„É≠„Éº„ÉóÔºàÊªë„ÇäÂè∞Ôºâ
            const slope = new THREE.Mesh(new THREE.PlaneGeometry(20, 60), new THREE.MeshStandardMaterial({color:0x888888, side:THREE.DoubleSide}));
            slope.rotation.x = -Math.PI/2 - 0.3; 
            slope.position.set(-30, 8, -40);
            scene.add(slope);
            colliders.push(slope);
        }

        function spawnDummy(index) {
            const group = new THREE.Group();
            const mat = new THREE.MeshPhongMaterial({ color: 0xcc2222 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8), mat);
            body.position.y = 0.9;
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.35), new THREE.MeshPhongMaterial({ color: 0x550000 }));
            head.position.y = 2.0;
            
            group.add(body);
            group.add(head);
            group.position.set((Math.random()-0.5)*50, 0, (Math.random()-0.5)*50 - 30);
            
            scene.add(group);
            enemies.push({ mesh: group, hp: 100, shield: 50, moveDir: 1, lastMove: 0, isDead: false });
        }

        function onKeyDown(e) {
            switch(e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': if(canJump) { velocity.y = JUMP_FORCE; canJump = false; } break;
                case 'ShiftLeft': isSprinting = true; break;
                case 'KeyC': 
                    if(!isCrouching) startSlide();
                    isCrouching = true; 
                    break;
                case 'KeyR': reload(); break;
            }
        }
        function onKeyUp(e) {
            switch(e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft': isSprinting = false; break;
                case 'KeyC': 
                    isCrouching = false; isSliding = false; 
                    camera.position.y = PLAYER_HEIGHT; 
                    break;
            }
        }

        function startSlide() {
            if(moveForward && isSprinting) {
                isSliding = true;
                slideVelocity = SLIDE_SPEED_INIT;
                camera.position.y = CROUCH_HEIGHT;
            } else {
                camera.position.y = CROUCH_HEIGHT;
            }
        }

        function reload() {
            if(isReloading || ammo === MAG_SIZE) return;
            isReloading = true;
            uiAmmo.style.color = "#aaa";
            document.getElementById('weapon-name').innerText = "RELOADING...";
            setTimeout(() => {
                ammo = MAG_SIZE; isReloading = false; uiAmmo.style.color = "#fff";
                document.getElementById('weapon-name').innerText = "R-301 CARBINE";
                updateUI();
            }, 1500);
        }

        function createDamageText(pos, amount, type) {
            const vec = pos.clone().project(camera);
            const x = (vec.x * .5 + .5) * window.innerWidth;
            const y = (-(vec.y * .5) + .5) * window.innerHeight;
            if(vec.z > 1.0) return;

            const el = document.createElement('div');
            el.innerText = amount;
            el.className = 'dmg-num';
            if(type === 'shield') el.classList.add('dmg-shield');
            else if(type === 'head') el.classList.add('dmg-head');
            else el.classList.add('dmg-health');

            el.style.left = x + 'px'; el.style.top = y + 'px';
            damageOverlay.appendChild(el);
            setTimeout(() => el.remove(), 800);
        }

        function fireWeapon() {
            if(ammo <= 0) { reload(); return; }
            ammo--; updateUI();

            crosshairCircle.style.width = "40px"; crosshairCircle.style.height = "40px";
            setTimeout(() => { crosshairCircle.style.width = "20px"; crosshairCircle.style.height = "20px"; }, 100);
            
            // „É™„Ç≥„Ç§„É´
            controls.getObject().rotation.x += RECOIL_AMOUNT * 2;

            // „É¨„Ç§„Ç≠„É£„Çπ„Éà
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera( new THREE.Vector2(), camera );
            
            // Âºæ„ÅÆËªåË∑°
            const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffffaa });
            const bullet = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 3), bulletMat);
            bullet.position.copy(camera.position);
            bullet.position.y -= 0.2;
            bullet.quaternion.copy(camera.quaternion);
            bullet.translateZ(-2);
            scene.add(bullet);
            setTimeout(()=>scene.remove(bullet), 50);

            const intersects = raycaster.intersectObjects(scene.children, true);
            for(let hit of intersects) {
                let target = hit.object;
                while(target.parent && target.parent.type !== 'Scene') target = target.parent;
                
                const enemy = enemies.find(e => e.mesh === target);
                if(enemy && !enemy.isDead) {
                    const isHead = hit.point.y > enemy.mesh.position.y + 1.5;
                    let dmg = isHead ? 22 : 11;
                    let type = 'health';

                    if(enemy.shield > 0) {
                        enemy.shield -= dmg; type = 'shield';
                        if(enemy.shield < 0) { enemy.hp += enemy.shield; enemy.shield = 0; createDamageText(hit.point, "CRACKED", 'shield'); }
                    } else {
                        enemy.hp -= dmg; type = isHead ? 'head' : 'health';
                    }
                    createDamageText(hit.point, dmg, type);

                    if(enemy.hp <= 0) {
                        enemy.isDead = true; enemy.mesh.visible = false;
                        const log = document.createElement('div');
                        log.className = 'feed-item'; log.innerText = "YOU üî´ DUMMY";
                        document.getElementById('kill-feed').appendChild(log);
                        setTimeout(()=>log.remove(), 3000);
                        setTimeout(() => { enemy.hp = 100; enemy.shield = 50; enemy.isDead = false; enemy.mesh.visible = true; }, 5000);
                    }
                    break;
                }
                if(hit.distance < 100 && !enemy) break;
            }
        }

        function updateUI() {
            uiShield.style.width = shield + "%";
            uiHealth.style.width = hp + "%";
            uiAmmo.innerText = ammo;
            uiMag.style.width = (ammo / MAG_SIZE * 100) + "%";
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if(controls.isLocked) {
                const time = performance.now();
                const delta = (time - prevTime) / 1000;

                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                let speed = MOVE_SPEED;
                if(isSliding) {
                    speed = slideVelocity; slideVelocity -= 15 * delta;
                    if(slideVelocity < 5) isSliding = false;
                } else if(isSprinting) speed = SPRINT_SPEED;
                else if(isCrouching) speed = MOVE_SPEED * 0.5;
                if(!canJump) speed *= 0.3;

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * 10.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * 10.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                let groundY = 0;
                let currentHeight = isCrouching ? CROUCH_HEIGHT : PLAYER_HEIGHT;
                if (controls.getObject().position.y < currentHeight) {
                    velocity.y = 0;
                    controls.getObject().position.y = currentHeight;
                    canJump = true;
                }

                if(isFiring && !isReloading && time - lastShotTime > FIRE_RATE) {
                    fireWeapon(); lastShotTime = time;
                }

                // Êïµ„ÅÆ„É¨„É¨„É¨Âãï„Åç
                for(const enemy of enemies) {
                    if(enemy.isDead) continue;
                    enemy.mesh.lookAt(controls.getObject().position.x, enemy.mesh.position.y, controls.getObject().position.z);
                    if(time - enemy.lastMove > 1000 + Math.random()*2000) {
                        enemy.moveDir *= -1; enemy.lastMove = time;
                    }
                    enemy.mesh.translateX(enemy.moveDir * 3.0 * delta);
                }

                prevTime = time;
            } else {
                prevTime = performance.now();
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
