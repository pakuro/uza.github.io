<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>2D War Strategy: LINE DEFENSE</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; font-family: 'Arial Black', sans-serif; user-select: none; }
        
        /* ゲーム画面 */
        canvas { display: block; width: 100vw; height: 100vh; background: #87CEEB; }

        /* UIレイヤー */
        #ui-layer {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 140px;
            background: rgba(0,0,0,0.8); border-top: 4px solid #fff;
            display: flex; justify-content: center; align-items: center; gap: 10px;
            padding-bottom: 10px;
        }

        /* ユニットボタン */
        .btn {
            width: 100px; height: 90px;
            background: #444; color: white; border: 2px solid #666; border-radius: 8px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            cursor: pointer; position: relative; transition: 0.1s;
        }
        .btn:active { transform: scale(0.95); background: #555; }
        .btn.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(100%); }
        .cost { color: #ffff00; font-size: 14px; margin-top: 5px; }
        .name { font-size: 16px; font-weight: bold; }
        
        /* アップグレードボタン */
        #btn-upgrade { background: #0055aa; border-color: #0077cc; }

        /* 資金表示 */
        #money-display {
            position: absolute; top: -40px; left: 20px;
            color: #ffff00; font-size: 30px; text-shadow: 2px 2px 0 #000;
        }

        /* ゲームオーバー/クリア画面 */
        #overlay {
            position: absolute; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; display: none;
        }
        #overlay h1 { font-size: 60px; margin: 0; color: #ff3333; text-transform: uppercase; }
        #restart-btn {
            margin-top: 30px; padding: 15px 50px; font-size: 24px; cursor: pointer;
            background: #fff; color: #000; border: none; font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="money-display">MONEY: $0</div>
        
        <div class="btn" id="btn-soldier" onclick="spawnPlayerUnit('soldier')">
            <div class="name">SOLDIER</div>
            <div class="cost">$50</div>
            <div style="font-size:10px; color:#aaa;">Basic</div>
        </div>
        
        <div class="btn" id="btn-tank" onclick="spawnPlayerUnit('tank')">
            <div class="name">TANK</div>
            <div class="cost">$200</div>
            <div style="font-size:10px; color:#aaa;">High HP</div>
        </div>

        <div class="btn" id="btn-sniper" onclick="spawnPlayerUnit('sniper')">
            <div class="name">SNIPER</div>
            <div class="cost">$350</div>
            <div style="font-size:10px; color:#aaa;">Long Range</div>
        </div>

        <div style="width:20px;"></div> <div class="btn" id="btn-upgrade" onclick="upgradeWallet()">
            <div class="name">UPGRADE</div>
            <div class="cost" id="upg-cost">$500</div>
            <div style="font-size:10px; color:#aaa;">Speed Up</div>
        </div>
    </div>

    <div id="overlay">
        <h1 id="result-text">VICTORY</h1>
        <button id="restart-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        // --- 設定 ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // ユニットデータ定義
        const UNIT_TYPES = {
            soldier: { cost: 50, hp: 50, dmg: 10, range: 40, speed: 2, reload: 40, color: '#33ff33', size: 15, w: 10, h: 20 },
            tank:    { cost: 200, hp: 400, dmg: 40, range: 60, speed: 1, reload: 100, color: '#3366ff', size: 30, w: 40, h: 30 },
            sniper:  { cost: 350, hp: 40, dmg: 80, range: 250, speed: 1.5, reload: 120, color: '#ff33ff', size: 15, w: 10, h: 25 }
        };

        // ゲーム状態
        let gameState = 'playing'; // playing, win, lose
        let frame = 0;
        let money = 200;
        let moneyRate = 1; // 収入増加率
        let upgradeCost = 500;
        
        // エンティティ
        const GROUND_Y = window.innerHeight - 200; // 地面の高さ
        let units = [];
        let particles = [];
        let projectiles = [];

        // 基地
        const basePlayer = { x: 50, hp: 2000, maxHp: 2000, team: 'player', color: '#00ccff' };
        const baseEnemy = { x: window.innerWidth - 150, hp: 2000, maxHp: 2000, team: 'enemy', color: '#ff3333' };

        // リサイズ対応
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            baseEnemy.x = canvas.width - 150;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- クラス定義 ---

        class Unit {
            constructor(type, team) {
                const data = UNIT_TYPES[type];
                this.type = type;
                this.team = team;
                this.hp = data.hp;
                this.maxHp = data.hp;
                this.dmg = data.dmg;
                this.range = data.range;
                this.speed = data.speed;
                this.reloadTime = data.reload;
                this.color = data.color;
                this.w = data.w;
                this.h = data.h;

                this.cooldown = 0;
                this.state = 'move'; // move, attack, idle

                // 出現位置
                if (team === 'player') {
                    this.x = basePlayer.x + 60;
                    this.vx = this.speed;
                } else {
                    this.x = baseEnemy.x - 60;
                    this.vx = -this.speed;
                }
                this.y = GROUND_Y - this.h;
            }

            update() {
                // 1. 最も近い敵を探す
                let target = null;
                let minDist = 9999;

                // 敵ユニットを探す
                units.forEach(u => {
                    if (u.team !== this.team) {
                        const dist = Math.abs(u.x - this.x);
                        if (dist < minDist) {
                            minDist = dist;
                            target = u;
                        }
                    }
                });

                // 敵基地もターゲット候補
                const baseTarget = (this.team === 'player') ? baseEnemy : basePlayer;
                const baseDist = Math.abs(baseTarget.x - this.x);
                if (baseDist < minDist) {
                    minDist = baseDist;
                    target = baseTarget; // 基地を攻撃対象にする
                    // 基地はオブジェクトなので簡易的に処理
                    target.isBase = true; 
                }

                // 2. 行動決定
                if (target && minDist <= this.range) {
                    this.state = 'attack';
                    this.cooldown--;
                    if (this.cooldown <= 0) {
                        this.attack(target);
                        this.cooldown = this.reloadTime;
                    }
                } else {
                    this.state = 'move';
                    this.x += this.vx;
                    this.cooldown = Math.max(0, this.cooldown - 1);
                }
            }

            attack(target) {
                // 弾を発射
                projectiles.push(new Projectile(this.x, this.y + this.h/2, target, this.dmg, this.team));
            }

            takeDamage(amount) {
                this.hp -= amount;
                // ダメージポップアップ的なエフェクト（簡易）
                spawnParticles(this.x, this.y + this.h/2, 3, '#fff');
            }

            draw() {
                ctx.fillStyle = (this.team === 'enemy') ? '#ff5555' : this.color;
                
                // 体の描画
                if (this.type === 'tank') {
                    // 戦車っぽい形
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                    ctx.fillRect(this.x - this.w/2 + (this.team==='player'?10:-10), this.y-10, 20, 10); // 砲塔
                } else if(this.type === 'sniper') {
                     // 細長い
                     ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                     // 銃
                     ctx.fillStyle = '#000';
                     ctx.fillRect(this.x, this.y + 5, (this.team==='player'?20:-20), 2);
                } else {
                    // 歩兵
                    ctx.fillRect(this.x - this.w/2, this.y, this.w, this.h);
                }

                // HPバー
                const pct = this.hp / this.maxHp;
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - 15, this.y - 10, 30, 4);
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(this.x - 15, this.y - 10, 30 * pct, 4);
            }
        }

        class Projectile {
            constructor(x, y, target, dmg, team) {
                this.x = x;
                this.y = y;
                this.target = target; // 追尾はしないが着弾判定に使う
                this.dmg = dmg;
                this.team = team;
                this.speed = 8;
                this.active = true;

                // ターゲット方向へ飛ぶ
                const tx = (target.isBase) ? (target.x + (team==='player'?-50:50)) : target.x;
                const ty = (target.isBase) ? (GROUND_Y - 50) : (target.y + target.h/2);
                
                const dx = tx - x;
                const dy = ty - y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                this.vx = (dx / dist) * this.speed;
                this.vy = (dy / dist) * this.speed;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                // 地面衝突
                if(this.y > GROUND_Y) this.active = false;

                // 簡易当たり判定（ターゲットとの距離）
                // 本来は全ユニット判定すべきだが軽量化のためターゲットとの距離を見る
                // もしターゲットが死んでたら、その場に爆発
                let hit = false;
                
                if (this.target.isBase) {
                     // 基地判定
                     if (Math.abs(this.x - this.target.x) < 80) {
                         this.target.hp -= this.dmg;
                         hit = true;
                     }
                } else if (units.includes(this.target)) {
                    // ユニット判定
                    if (Math.abs(this.x - this.target.x) < 20 && Math.abs(this.y - (this.target.y + this.target.h/2)) < 20) {
                        this.target.takeDamage(this.dmg);
                        hit = true;
                    }
                } else {
                    // ターゲットが消滅していた場合、近くの敵に当たるか消える
                    if (this.y > GROUND_Y - 20) this.active = false; 
                }

                if (hit) {
                    this.active = false;
                    spawnParticles(this.x, this.y, 5, 'orange');
                }
            }

            draw() {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 5;
                this.vy = (Math.random() - 0.5) * 5;
                this.life = 1.0;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.05;
            }
            draw() {
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, 4, 4);
                ctx.globalAlpha = 1.0;
            }
        }

        // --- ゲームループ制御 ---

        function spawnParticles(x, y, count, color) {
            for(let i=0; i<count; i++) particles.push(new Particle(x, y, color));
        }

        function spawnPlayerUnit(type) {
            if (gameState !== 'playing') return;
            const cost = UNIT_TYPES[type].cost;
            if (money >= cost) {
                money -= cost;
                units.push(new Unit(type, 'player'));
            }
        }

        function upgradeWallet() {
            if (money >= upgradeCost) {
                money -= upgradeCost;
                moneyRate++;
                upgradeCost += 500;
                document.getElementById('upg-cost').innerText = "$" + upgradeCost;
            }
        }

        // 敵AI
        let enemyTimer = 0;
        function updateEnemyAI() {
            enemyTimer++;
            // 時間経過で強くなる
            const difficulty = 1 + (frame / 3600); // 1分ごとに強化
            
            // プレイヤーが近づいてきたら防衛する、などのロジック
            if (enemyTimer > 100 / difficulty) {
                // ランダムにユニット生成
                const r = Math.random();
                let type = 'soldier';
                if (r < 0.2 && frame > 600) type = 'tank';
                if (r < 0.1 && frame > 1200) type = 'sniper';
                
                // お金無限（敵チート）だがクールダウンで制限
                units.push(new Unit(type, 'enemy'));
                enemyTimer = 0;
            }
        }

        function update() {
            if (gameState !== 'playing') return;
            frame++;

            // お金増加
            if (frame % 10 === 0) money += moneyRate;
            document.getElementById('money-display').innerText = "MONEY: $" + Math.floor(money);
            
            // ボタンの有効/無効切り替え
            ['soldier', 'tank', 'sniper'].forEach(type => {
                const btn = document.getElementById('btn-'+type);
                if (money >= UNIT_TYPES[type].cost) btn.classList.remove('disabled');
                else btn.classList.add('disabled');
            });
            const upgBtn = document.getElementById('btn-upgrade');
            if (money >= upgradeCost) upgBtn.classList.remove('disabled');
            else upgBtn.classList.add('disabled');

            // AI
            updateEnemyAI();

            // ユニット更新
            units.forEach(u => u.update());
            units = units.filter(u => u.hp > 0);

            // 弾更新
            projectiles.forEach(p => p.update());
            projectiles = projectiles.filter(p => p.active);

            // パーティクル更新
            particles.forEach(p => p.update());
            particles = particles.filter(p => p.life > 0);

            // 勝敗判定
            if (basePlayer.hp <= 0) endGame(false);
            if (baseEnemy.hp <= 0) endGame(true);
        }

        function draw() {
            // 背景（空と地面）
            ctx.fillStyle = '#87CEEB'; // Sky
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#44aa44'; // Ground
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);

            // 基地
            drawBase(basePlayer);
            drawBase(baseEnemy);

            // オブジェクト
            units.forEach(u => u.draw());
            projectiles.forEach(p => p.draw());
            particles.forEach(p => p.draw());

            requestAnimationFrame(() => {
                update();
                draw();
            });
        }

        function drawBase(base) {
            ctx.fillStyle = base.color;
            // ドーム型基地
            ctx.beginPath();
            ctx.arc(base.x, GROUND_Y, 60, Math.PI, 0);
            ctx.fill();
            
            // HPバー
            const pct = Math.max(0, base.hp / base.maxHp);
            ctx.fillStyle = '#333';
            ctx.fillRect(base.x - 50, GROUND_Y - 100, 100, 10);
            ctx.fillStyle = (pct > 0.5) ? '#00ff00' : 'red';
            ctx.fillRect(base.x - 50, GROUND_Y - 100, 100 * pct, 10);
        }

        function endGame(win) {
            gameState = (win) ? 'win' : 'lose';
            const ov = document.getElementById('overlay');
            const txt = document.getElementById('result-text');
            ov.style.display = 'flex';
            if (win) {
                txt.innerText = "VICTORY!";
                txt.style.color = "#00ffcc";
            } else {
                txt.innerText = "DEFEAT...";
                txt.style.color = "#ff3333";
            }
        }

        // 開始
        draw();

    </script>
</body>
</html>
