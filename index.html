<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Block Blast Pro</title>
<style>
body{
    margin:0;
    background:#f4f6fb;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:sans-serif;
}
#container{
    text-align:center;
}
#board{
    display:grid;
    grid-template-columns:repeat(8,60px);
    gap:6px;
    background:#2b2f3a;
    padding:12px;
    border-radius:15px;
}
.cell{
    width:60px;
    height:60px;
    background:#e0e4f2;
    border-radius:10px;
}
.filled{
    box-shadow:inset -4px -4px 8px rgba(0,0,0,0.2),
               inset 4px 4px 8px rgba(255,255,255,0.4);
}
.highlight{
    background:#c3ffcc !important;
}
#pieces{
    margin-top:20px;
}
.piece{
    display:inline-block;
    margin:15px;
    cursor:grab;
}
.piece-cell{
    width:20px;
    height:20px;
    display:inline-block;
    border-radius:4px;
}
button{
    margin:5px;
    padding:8px 15px;
}
</style>
</head>
<body>
<div id="container">
<h2>Block Blast 8×8 Pro</h2>
<button onclick="mode='player'">プレイヤー</button>
<button onclick="mode='ai'">AI</button>
<div id="board"></div>
<div id="pieces"></div>
<h3 id="status"></h3>
</div>

<script>
const size=8;
let board=[];
let pieces=[];
let dragging=null;
let mode="player";

const shapes=[
[[1]],
[[1,1]],
[[1,1,1]],
[[1,1,1,1]],
[[1,1,1,1,1]],
[[1],[1]],
[[1],[1],[1]],
[[1,1],[1,1]],
[[1,0],[1,1]],
[[1,1,1],[0,1,0]],
[[1,1,0],[0,1,1]],
[[0,1,1],[1,1,0]],
[[1,1,1],[1,1,1],[1,1,1]],
[[1,1,1],[1,1,1]]
];

function randomColor(){
    return `linear-gradient(145deg,
        hsl(${Math.random()*360},70%,70%),
        hsl(${Math.random()*360},70%,50%))`;
}

function init(){
    board=Array(size).fill().map(()=>Array(size).fill(0));
    generatePieces();
    draw();
}

function draw(){
    const b=document.getElementById("board");
    b.innerHTML="";
    for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
            const c=document.createElement("div");
            c.className="cell";
            if(board[y][x]){
                c.classList.add("filled");
                c.style.background=board[y][x];
            }
            c.dataset.y=y;
            c.dataset.x=x;
            b.appendChild(c);
        }
    }
}

function drawPieces(){
    const p=document.getElementById("pieces");
    p.innerHTML="";
    pieces.forEach((obj,i)=>{
        const div=document.createElement("div");
        div.className="piece";
        div.draggable=true;
        div.ondragstart=()=>dragging=i;

        obj.shape.forEach(row=>{
            const rowDiv=document.createElement("div");
            row.forEach(cell=>{
                const c=document.createElement("div");
                c.className="piece-cell";
                if(cell){
                    c.style.background=obj.color;
                    c.style.boxShadow="inset -2px -2px 4px rgba(0,0,0,0.2)";
                }
                rowDiv.appendChild(c);
            });
            div.appendChild(rowDiv);
        });
        p.appendChild(div);
    });
}

document.addEventListener("dragover",e=>e.preventDefault());

document.addEventListener("drop",e=>{
    if(mode!=="player") return;
    const cell=e.target;
    if(!cell.classList.contains("cell")) return;
    const y=parseInt(cell.dataset.y);
    const x=parseInt(cell.dataset.x);
    const obj=pieces[dragging];
    if(canPlace(obj.shape,y,x)){
        place(obj,y,x);
        pieces.splice(dragging,1);
        if(pieces.length===0) generatePieces();
        draw();
        drawPieces();
    }
});

function canPlace(shape,y,x){
    for(let dy=0;dy<shape.length;dy++){
        for(let dx=0;dx<shape[0].length;dx++){
            if(shape[dy][dx]){
                if(y+dy>=size||x+dx>=size||board[y+dy][x+dx])
                    return false;
            }
        }
    }
    return true;
}

function place(obj,y,x){
    for(let dy=0;dy<obj.shape.length;dy++){
        for(let dx=0;dx<obj.shape[0].length;dx++){
            if(obj.shape[dy][dx])
                board[y+dy][x+dx]=obj.color;
        }
    }
    clearLines();
}

function clearLines(){
    for(let i=0;i<size;i++){
        if(board[i].every(v=>v)) board[i].fill(0);
        if(board.map(r=>r[i]).every(v=>v)){
            for(let j=0;j<size;j++) board[j][i]=0;
        }
    }
}

function generatePieces(){
    let trial=[];
    let nineCount=0;

    for(let i=0;i<3;i++){
        let shape=shapes[Math.floor(Math.random()*shapes.length)];
        if(shape.length===3 && shape[0].length===3) nineCount++;
        trial.push({shape:shape,color:randomColor()});
    }

    if(nineCount>=2 && Math.random()<0.6){
        trial[2]={shape:[[1,1,1],[1,1,1]],color:randomColor()};
    }

    pieces=trial;
    drawPieces();
}

function aiMove(){
    if(mode!=="ai") return;

    for(let i=0;i<pieces.length;i++){
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                if(canPlace(pieces[i].shape,y,x)){
                    place(pieces[i],y,x);
                    pieces.splice(i,1);
                    if(pieces.length===0) generatePieces();
                    draw();
                    drawPieces();
                    return;
                }
            }
        }
    }
}

setInterval(aiMove,700); // ← 0.7倍速

init();
drawPieces();
</script>
</body>
</html>
