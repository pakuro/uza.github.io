<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Block Blast Touch</title>
<style>
body{
    margin:0;
    background:#f5f6fa;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:sans-serif;
    touch-action:none;
}
#container{text-align:center;}
#board{
    display:grid;
    grid-template-columns:repeat(8,50px);
    gap:5px;
    background:#dcdde1;
    padding:10px;
    border-radius:12px;
}
.cell{
    width:50px;
    height:50px;
    background:white;
    border-radius:10px;
}
.filled{border-radius:10px;}

#pieces{margin-top:20px;}
.piece{
    display:inline-block;
    margin:10px;
    position:relative;
}
.block{
    width:18px;
    height:18px;
    display:inline-block;
    border-radius:4px;
}

.dragging{
    position:fixed;
    pointer-events:none;
    opacity:0.9;
    z-index:999;
}
button{margin:5px;padding:6px 12px;}
</style>
</head>
<body>
<div id="container">
<h2>Block Blast</h2>
<button onclick="mode='player'">プレイヤー</button>
<button onclick="mode='ai'">AI</button>
<div id="board"></div>
<div id="pieces"></div>
<h3 id="status"></h3>
</div>

<script>
const size=8;
let board=[];
let pieces=[];
let mode="player";
let draggingIndex=null;
let dragElement=null;

const shapes=[
[[1]],
[[1,1]],
[[1,1,1]],
[[1,1,1,1]],
[[1],[1]],
[[1],[1],[1]],
[[1,1],[1,1]],
[[1,0],[1,1]],
[[1,1,0],[0,1,1]],
[[1,1,1],[0,1,0]]
];

function randomColor(){
    return `hsl(${Math.random()*360},70%,60%)`;
}

function init(){
    board=Array(size).fill().map(()=>Array(size).fill(0));
    generatePieces();
    draw();
}

function draw(){
    const b=document.getElementById("board");
    b.innerHTML="";
    for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
            const c=document.createElement("div");
            c.className="cell";
            if(board[y][x]){
                c.classList.add("filled");
                c.style.background=board[y][x];
            }
            c.dataset.y=y;
            c.dataset.x=x;
            b.appendChild(c);
        }
    }
}

function drawPieces(){
    const p=document.getElementById("pieces");
    p.innerHTML="";
    pieces.forEach((obj,i)=>{
        const div=document.createElement("div");
        div.className="piece";
        div.dataset.index=i;

        obj.shape.forEach(row=>{
            const r=document.createElement("div");
            row.forEach(cell=>{
                const b=document.createElement("div");
                b.className="block";
                if(cell) b.style.background=obj.color;
                r.appendChild(b);
            });
            div.appendChild(r);
        });

        div.addEventListener("touchstart",startDrag);
        div.addEventListener("mousedown",startDrag);

        p.appendChild(div);
    });
}

function startDrag(e){
    if(mode!=="player") return;

    draggingIndex=parseInt(e.currentTarget.dataset.index);

    dragElement=e.currentTarget.cloneNode(true);
    dragElement.classList.add("dragging");
    document.body.appendChild(dragElement);

    moveDrag(e);

    document.addEventListener("touchmove",moveDrag);
    document.addEventListener("mousemove",moveDrag);
    document.addEventListener("touchend",endDrag);
    document.addEventListener("mouseup",endDrag);
}

function moveDrag(e){
    if(!dragElement) return;
    let touch=e.touches?e.touches[0]:e;
    dragElement.style.left=touch.clientX-30+"px";
    dragElement.style.top=touch.clientY-30+"px";
}

function endDrag(e){
    if(!dragElement) return;

    let touch=e.changedTouches?e.changedTouches[0]:e;
    let element=document.elementFromPoint(touch.clientX,touch.clientY);

    if(element && element.classList.contains("cell")){
        let y=parseInt(element.dataset.y);
        let x=parseInt(element.dataset.x);
        let obj=pieces[draggingIndex];
        if(canPlace(obj.shape,y,x)){
            place(obj,y,x);
            pieces.splice(draggingIndex,1);
            if(pieces.length===0) generatePieces();
            update();
        }
    }

    dragElement.remove();
    dragElement=null;
    draggingIndex=null;

    document.removeEventListener("touchmove",moveDrag);
    document.removeEventListener("mousemove",moveDrag);
    document.removeEventListener("touchend",endDrag);
    document.removeEventListener("mouseup",endDrag);
}

function canPlace(shape,y,x){
    for(let dy=0;dy<shape.length;dy++){
        for(let dx=0;dx<shape[0].length;dx++){
            if(shape[dy][dx]){
                if(y+dy>=size||x+dx>=size||board[y+dy][x+dx])
                    return false;
            }
        }
    }
    return true;
}

function place(obj,y,x){
    for(let dy=0;dy<obj.shape.length;dy++){
        for(let dx=0;dx<obj.shape[0].length;dx++){
            if(obj.shape[dy][dx])
                board[y+dy][x+dx]=obj.color;
        }
    }
    clearLines();
}

function clearLines(){
    for(let i=0;i<size;i++){
        if(board[i].every(v=>v)) board[i].fill(0);
        if(board.map(r=>r[i]).every(v=>v)){
            for(let j=0;j<size;j++) board[j][i]=0;
        }
    }
}

function generatePieces(){
    pieces=[];
    for(let i=0;i<3;i++){
        let shape=shapes[Math.floor(Math.random()*shapes.length)];
        pieces.push({shape:shape,color:randomColor()});
    }
    drawPieces();
}

function update(){
    draw();
    drawPieces();
    if(!anyMove()) gameOver();
}

function anyMove(){
    for(let obj of pieces){
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                if(canPlace(obj.shape,y,x)) return true;
            }
        }
    }
    return false;
}

function gameOver(){
    document.getElementById("status").innerText="ゲームオーバー";
    mode="stop";
}

/* AI */
function aiMove(){
    if(mode!=="ai") return;
    for(let i=0;i<pieces.length;i++){
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                if(canPlace(pieces[i].shape,y,x)){
                    place(pieces[i],y,x);
                    pieces.splice(i,1);
                    if(pieces.length===0) generatePieces();
                    update();
                    return;
                }
            }
        }
    }
}
setInterval(aiMove,700);

init();
drawPieces();
</script>
</body>
</html>
