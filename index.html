<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
  <title>Babylon iPad RPG Prototype</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <style>
    html,body{width:100%;height:100%;margin:0;padding:0;overflow:hidden;background:#e6f0ff}
    #renderCanvas{width:100%;height:100%;touch-action:none;display:block}
    /* touch UI styles (same as playground prototype) */
    .vjoy { position: fixed; left: 18px; bottom: 18px; width: 140px; height: 140px; border-radius: 70px; background: rgba(200,200,200,0.08); touch-action:none; z-index:9999; }
    .vjoy .nub { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:64px; height:64px; border-radius:32px; background: rgba(200,200,200,0.28); }
    .btn { position: fixed; right: 18px; bottom: 18px; width:84px; height:84px; border-radius:42px; background: rgba(255,80,80,0.9); z-index:9999; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; font-size:18px; touch-action:none;}
    .btn2 { position: fixed; right: 110px; bottom: 18px; width:64px; height:64px; border-radius:32px; background: rgba(80,150,255,0.95); z-index:9999; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; font-size:16px; touch-action:none;}
    .btn3 { position: fixed; right: 18px; bottom: 110px; width:64px; height:64px; border-radius:32px; background: rgba(150,80,255,0.95); z-index:9999; display:flex; align-items:center; justify-content:center; font-weight:bold; color:white; font-size:16px; touch-action:none;}
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <script>
  (function(){
    const canvas = document.getElementById('renderCanvas');
    const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});

    function createScene() {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color3(0.8,0.9,1);

      const light = new BABYLON.HemisphericLight('h', new BABYLON.Vector3(0,1,0), scene);
      light.intensity = 0.9;

      const ground = BABYLON.MeshBuilder.CreateGround('g',{width:120,height:120},scene);
      ground.receiveShadows = true;

      // player
      const player = new BABYLON.TransformNode('player', scene);
      const body = BABYLON.MeshBuilder.CreateBox('body',{height:1.6,width:0.7,depth:0.4},scene);
      body.parent = player; body.position.y = 0.9;
      const head = BABYLON.MeshBuilder.CreateSphere('head',{diameter:0.45},scene);
      head.parent = player; head.position.y = 1.65;
      const pm = new BABYLON.StandardMaterial('pm',scene); pm.diffuseColor = new BABYLON.Color3(0.2,0.5,0.8);
      body.material = pm; head.material = pm;
      player.position = new BABYLON.Vector3(0,0,0);
      player.hp = 100; player.maxHp = 100; player.speed = 3.0;

      // camera (FollowCamera)
      const camera = new BABYLON.FollowCamera('cam', new BABYLON.Vector3(0,3,-6), scene);
      camera.lockedTarget = player; camera.radius = 6; camera.heightOffset = 2; camera.rotationOffset = 0;
      camera.cameraAcceleration = 0.05; camera.maxCameraSpeed = 10;
      camera.attachControl(canvas, true);

      // GUI
      const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('ui', true, scene);
      const playerHPBar = new BABYLON.GUI.Rectangle();
      playerHPBar.width = '220px'; playerHPBar.height = '28px'; playerHPBar.cornerRadius = 5; playerHPBar.color = 'black'; playerHPBar.thickness = 2;
      playerHPBar.background = 'rgba(0,0,0,0.3)'; playerHPBar.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
      playerHPBar.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP; playerHPBar.left = '12px'; playerHPBar.top = '12px';
      gui.addControl(playerHPBar);
      const playerHPFill = new BABYLON.GUI.Rectangle(); playerHPFill.width = '100%'; playerHPFill.height = '100%'; playerHPFill.background = 'green'; playerHPFill.cornerRadius = 5; playerHPBar.addControl(playerHPFill);
      const playerHPText = new BABYLON.GUI.TextBlock(); playerHPText.text = 'HP: 100/100'; playerHPText.color = 'white'; playerHPText.fontSize = 14; playerHPBar.addControl(playerHPText);

      // enemy creation
      function createEnemy(posX,posZ) {
        const root = new BABYLON.TransformNode('enemyRoot', scene);
        const mesh = BABYLON.MeshBuilder.CreateBox('enemy',{height:1.6,width:0.8,depth:0.5},scene);
        mesh.parent = root; mesh.position.y = 0.8;
        const em = new BABYLON.StandardMaterial('em',scene); em.diffuseColor = new BABYLON.Color3(0.8,0.2,0.2);
        mesh.material = em;
        root.position = new BABYLON.Vector3(posX,0,posZ);
        root.hp = 120; root.maxHp = 120; root.isAlive = true;
        const eBar = new BABYLON.GUI.Rectangle(); eBar.width='140px'; eBar.height='12px'; eBar.background='rgba(0,0,0,0.5)'; eBar.cornerRadius=4; eBar.thickness=1; eBar.color='black'; gui.addControl(eBar);
        eBar.linkWithMesh(root); eBar.linkOffsetY = -120;
        const eFill = new BABYLON.GUI.Rectangle(); eFill.width='100%'; eFill.height='100%'; eFill.background='red'; eFill.cornerRadius=4; eBar.addControl(eFill);
        root._hpFill = eFill; return root;
      }

      const enemy = createEnemy(0,12);

      // inputs
      let moveInput = {x:0,y:0};

      // create touch UI elements (DOM)
      (function createTouchUI(){
        // joystick
        const joy = document.createElement('div'); joy.className = 'vjoy';
        const nub = document.createElement('div'); nub.className = 'nub'; joy.appendChild(nub); document.body.appendChild(joy);
        const atk = document.createElement('div'); atk.className = 'btn'; atk.innerText='Attack'; document.body.appendChild(atk);
        const m1 = document.createElement('div'); m1.className='btn2'; m1.innerText='F1'; const m2 = document.createElement('div'); m2.className='btn3'; m2.innerText='F2'; document.body.appendChild(m1); document.body.appendChild(m2);

        let active=false, origin=null;
        joy.addEventListener('pointerdown',(e)=>{ active=true; origin={x:e.clientX,y:e.clientY}; joy.setPointerCapture(e.pointerId);});
        joy.addEventListener('pointermove',(e)=>{ if(!active) return; const dx=e.clientX-origin.x; const dy=e.clientY-origin.y; const max=40; const nx=Math.max(-max,Math.min(max,dx)); const ny=Math.max(-max,Math.min(max,dy)); nub.style.transform = `translate(${nx}px, ${ny}px)`; moveInput.x = nx/max; moveInput.y = -ny/max; });
        joy.addEventListener('pointerup',(e)=>{ active=false; origin=null; nub.style.transform='translate(-50%,-50%)'; moveInput.x=0; moveInput.y=0; joy.releasePointerCapture(e.pointerId);});

        // camera swipe
        let camTouch={active:false,id:null,lastX:0,lastY:0};
        canvas.addEventListener('pointerdown',(e)=>{ if(e.clientX > window.innerWidth/2){ camTouch.active=true; camTouch.id=e.pointerId; camTouch.lastX=e.clientX; camTouch.lastY=e.clientY; canvas.setPointerCapture(e.pointerId); } });
        canvas.addEventListener('pointermove',(e)=>{ if(!camTouch.active || camTouch.id!==e.pointerId) return; const dx = e.clientX-camTouch.lastX; const dy = e.clientY-camTouch.lastY; camTouch.lastX=e.clientX; camTouch.lastY=e.clientY; camera.alpha -= dx * 0.0025; camera.beta -= dy * 0.0025; camera.beta = Math.max(0.6, Math.min(1.5, camera.beta)); });
        canvas.addEventListener('pointerup',(e)=>{ if(camTouch.id === e.pointerId){ camTouch.active=false; camTouch.id=null; canvas.releasePointerCapture(e.pointerId); } });

        // attack & magic
        atk.addEventListener('pointerdown', (e)=>{ doAttack(); atk.style.transform='scale(0.95)'; }); atk.addEventListener('pointerup',(e)=>{ atk.style.transform='scale(1)'; });
        let lastFire=-9999, lastIce=-9999; const fireCooldown=3000, iceCooldown=5000;
        m1.addEventListener('pointerdown',(e)=>{ const now = performance.now(); if(now - lastFire >= fireCooldown){ lastFire = now; fireMagic(); m1.style.opacity='0.5'; setTimeout(()=>m1.style.opacity='1',300); } });
        m2.addEventListener('pointerdown',(e)=>{ const now = performance.now(); if(now - lastIce >= iceCooldown){ lastIce = now; iceMagic(); m2.style.opacity='0.5'; setTimeout(()=>m2.style.opacity='1',300); } });
      })();

      // attack
      const projectiles = [];
      function doAttack(){ const origin = player.position.add(new BABYLON.Vector3(0,1.2,0)); const forward = new BABYLON.Vector3(Math.sin(camera.alpha),0,Math.cos(camera.alpha)); const ray = new BABYLON.Ray(origin, forward, 3.0); const pick = scene.pickWithRay(ray, (m)=> m && m.parent === enemy);
        if(pick && pick.hit){ damageEnemy(enemy,25); }
        const s = BABYLON.MeshBuilder.CreateTorus('swing',{thickness:0.06,diameter:1.6,tessellation:24},scene); s.position = origin.add(forward.scale(1.2)); s.rotation.x = Math.PI/2; s.material = new BABYLON.StandardMaterial('sm',scene); s.material.emissiveColor = new BABYLON.Color3(1,0.6,0.1); setTimeout(()=>{ s.dispose(); },150);
      }

      function fireMagic(){ const origin = player.position.add(new BABYLON.Vector3(0,1.2,0)); const forward = new BABYLON.Vector3(Math.sin(camera.alpha),0,Math.cos(camera.alpha)); const proj = BABYLON.MeshBuilder.CreateSphere('fire',{diameter:0.4},scene); proj.position = origin.add(forward.scale(1.2)); proj.material = new BABYLON.StandardMaterial('fm',scene); proj.material.emissiveColor = new BABYLON.Color3(1,0.3,0.1); proj._vel = forward.scale(12); proj._life = 3000; proj._type='fire'; projectiles.push(proj); }
      function iceMagic(){ const origin = player.position.add(new BABYLON.Vector3(0,1.2,0)); const forward = new BABYLON.Vector3(Math.sin(camera.alpha),0,Math.cos(camera.alpha)); const proj = BABYLON.MeshBuilder.CreateSphere('ice',{diameter:0.45},scene); proj.position = origin.add(forward.scale(1.2)); proj.material = new BABYLON.StandardMaterial('im',scene); proj.material.emissiveColor = new BABYLON.Color3(0.4,0.8,1); proj._vel = forward.scale(10); proj._life = 3000; proj._type='ice'; projectiles.push(proj); }

      function damageEnemy(e,dmg){ if(!e.isAlive) return; e.hp -= dmg; e._hpFill.width = Math.max(0,(e.hp/e.maxHp)*100) + '%'; if(e.hp <= 0){ e.isAlive = false; const boom = BABYLON.MeshBuilder.CreateSphere('b',{diameter:1.6},scene); boom.position = e.position.add(new BABYLON.Vector3(0,1,0)); boom.material = new BABYLON.StandardMaterial('bm',scene); boom.material.emissiveColor = new BABYLON.Color3(1,0.3,0.1); setTimeout(()=>{ boom.dispose(); e.getChildren().forEach(c=>c.dispose()); try{ e.dispose(); }catch(e){} },400); } }

      // burn
      function applyBurn(target, ticks, dmg){ if(!target.isAlive) return; let count=0; const iv = setInterval(()=>{ if(!target.isAlive){ clearInterval(iv); return; } damageEnemy(target,dmg); count++; if(count>=ticks) clearInterval(iv); },600); }

      // game loop
      scene.onBeforeRenderObservable.add(()=>{
        const dt = scene.getEngine().getDeltaTime() / 1000;
        for(let i = projectiles.length-1;i>=0;i--){ const p = projectiles[i]; p.position.addInPlace(p._vel.scale(dt)); p._life -= dt*1000; if(enemy.isAlive && p.position.subtract(enemy.position).length() < 1.2){ if(p._type==='fire'){ damageEnemy(enemy,35); applyBurn(enemy,3,4); } else if(p._type==='ice'){ damageEnemy(enemy,18); enemy._slow = 2.5; } p.dispose(); projectiles.splice(i,1); continue; } if(p._life <= 0){ p.dispose(); projectiles.splice(i,1); } }

        // enemy movement
        if(enemy.isAlive){ const dir = player.position.subtract(enemy.position); const dist = dir.length(); if(dist > 2.0){ const speed = 1.5 * (enemy._slow ? 0.5 : 1.0); const m = dir.normalize().scale(-1 * speed * dt); enemy.position.addInPlace(m); } else { if(!enemy._lastAtk || performance.now() - enemy._lastAtk > 1200){ enemy._lastAtk = performance.now(); player.hp -= 12; playerHPFill.width = Math.max(0,(player.hp/player.maxHp)*100) + '%'; playerHPText.text = `HP: ${Math.max(0,player.hp)}/${player.maxHp}`; } } if(enemy._slow){ enemy._slowTimer = (enemy._slowTimer||0) + dt; if(enemy._slowTimer >= enemy._slow){ enemy._slow = 0; enemy._slowTimer = 0; } } }

        // movement
        if(Math.abs(moveInput.x) > 0.01 || Math.abs(moveInput.y) > 0.01){ const alpha = camera.alpha; const forward = new BABYLON.Vector3(Math.sin(alpha),0,Math.cos(alpha)); const right = new BABYLON.Vector3(forward.z * -1, 0, forward.x); const worldMove = forward.scale(moveInput.y).add(right.scale(moveInput.x)); if(worldMove.length() > 0.001){ const step = worldMove.normalize().scale(player.speed * dt); player.position.addInPlace(step); player.rotation = new BABYLON.Vector3(0, Math.atan2(worldMove.x, worldMove.z), 0); } }

        if(player.position.y < 0) player.position.y = 0;
        if(player.hp <= 0){ player.position = new BABYLON.Vector3(0,0,0); player.hp = player.maxHp; playerHPFill.width = '100%'; playerHPText.text = `HP: ${player.hp}/${player.maxHp}`; // respawn enemy
          enemy.position = new BABYLON.Vector3(0,0,12); enemy.hp = enemy.maxHp; enemy.isAlive = true; enemy._hpFill.width = '100%'; }
      });

      // initial camera
      camera.alpha = Math.PI; camera.beta = 0.9;
      const lightSphere = BABYLON.MeshBuilder.CreateSphere('ls',{diameter:0.2},scene); lightSphere.position = new BABYLON.Vector3(2,0.2,2); const lm = new BABYLON.StandardMaterial('lm',scene); lm.emissiveColor = new BABYLON.Color3(1,1,0.6); lightSphere.material = lm;

      return scene;
    }

    const scene = createScene();
    engine.runRenderLoop(()=>{ if(scene) scene.render(); });
    window.addEventListener('resize', ()=>{ engine.resize(); });
  })();
  </script>
</body>
</html>
