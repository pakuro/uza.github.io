<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Block Blast 最強AI</title>
<style>
body{
    margin:0;
    background:#f4f6fb;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    font-family:sans-serif;
}
#board{
    display:grid;
    grid-template-columns:repeat(8,55px);
    gap:6px;
    background:#dcdde1;
    padding:12px;
    border-radius:15px;
}
.cell{
    width:55px;
    height:55px;
    background:white;
    border-radius:12px;
}
.filled{border-radius:12px;}
</style>
</head>
<body>

<div>
<h2>最強AI Block Blast</h2>
<div>Score: <span id="score">0</span></div>
<button onclick="mode='player'">Player</button>
<button onclick="mode='ai'">AI</button>
<div id="board"></div>
<div id="status"></div>
</div>

<script>
const size=8;
let board=[];
let pieces=[];
let score=0;
let combo=0;
let mode="ai";

const shapes=[[[1]],[[1,1]],[[1,1,1]],[[1],[1]],[[1],[1],[1]],
[[1,1],[1,1]],[[1,0],[1,1]],[[1,1,1],[0,1,0]]];

function init(){
    board=Array(size).fill().map(()=>Array(size).fill(0));
    score=0;
    combo=0;
    generatePieces();
    draw();
}

function randomColor(){
    return `hsl(${Math.random()*360},70%,60%)`;
}

function generatePieces(){
    pieces=[];
    for(let i=0;i<3;i++){
        pieces.push({
            shape:shapes[Math.floor(Math.random()*shapes.length)],
            color:randomColor()
        });
    }
}

function draw(){
    const b=document.getElementById("board");
    b.innerHTML="";
    for(let y=0;y<size;y++){
        for(let x=0;x<size;x++){
            const c=document.createElement("div");
            c.className="cell";
            if(board[y][x]){
                c.classList.add("filled");
                c.style.background=board[y][x];
            }
            b.appendChild(c);
        }
    }
    document.getElementById("score").innerText=score;
}

function canPlace(shape,y,x,temp=board){
    for(let dy=0;dy<shape.length;dy++)
        for(let dx=0;dx<shape[0].length;dx++)
            if(shape[dy][dx]){
                if(y+dy>=size||x+dx>=size||temp[y+dy][x+dx])
                    return false;
            }
    return true;
}

function simulate(temp,obj,y,x){
    let placed=0;
    for(let dy=0;dy<obj.shape.length;dy++)
        for(let dx=0;dx<obj.shape[0].length;dx++)
            if(obj.shape[dy][dx]){
                temp[y+dy][x+dx]=1;
                placed++;
            }

    let lines=0;
    for(let i=0;i<size;i++){
        if(temp[i].every(v=>v)){
            lines++;
            temp[i].fill(0);
        }
        if(temp.map(r=>r[i]).every(v=>v)){
            lines++;
            for(let j=0;j<size;j++) temp[j][i]=0;
        }
    }

    return {placed,lines};
}

function evaluate(temp){
    let blocks=0;
    for(let y=0;y<size;y++)
        for(let x=0;x<size;x++)
            if(temp[y][x]) blocks++;
    return blocks;
}

function aiMove(){
    if(mode!=="ai") return;

    let best=null;
    let bestValue=Infinity;

    const perms=[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,0,1],[2,1,0]];

    for(let p of perms){
        let temp=JSON.parse(JSON.stringify(board));
        let totalLines=0;
        let valid=true;

        for(let idx of p){
            let moveFound=false;
            for(let y=0;y<size;y++){
                for(let x=0;x<size;x++){
                    if(canPlace(pieces[idx].shape,y,x,temp)){
                        let sim=JSON.parse(JSON.stringify(temp));
                        let {lines}=simulate(sim,pieces[idx],y,x);
                        temp=sim;
                        totalLines+=lines;
                        moveFound=true;
                        break;
                    }
                }
                if(moveFound) break;
            }
            if(!moveFound){ valid=false; break; }
        }

        if(!valid) continue;

        let value=evaluate(temp)-totalLines*20;

        if(value===0){ best=p; break; }

        if(value<bestValue){
            bestValue=value;
            best=p;
        }
    }

    if(!best){
        document.getElementById("status").innerText="Game Over";
        return;
    }

    for(let idx of best){
        for(let y=0;y<size;y++){
            for(let x=0;x<size;x++){
                if(canPlace(pieces[idx].shape,y,x)){
                    let {placed,lines}=simulate(board,pieces[idx],y,x);

                    score+=placed;
                    if(lines>0){
                        combo++;
                        score+=lines*100 + combo*50;
                    }else{
                        combo=0;
                    }

                    break;
                }
            }
            break;
        }
    }

    if(board.flat().every(v=>!v)){
        score+=1000;
    }

    generatePieces();
    draw();
}

setInterval(aiMove,800);

init();
draw();
</script>

</body>
</html>
