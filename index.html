<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Nebby Climb: New Game</title>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #222; touch-action: none; font-family: sans-serif; }
        #game-canvas { display: block; width: 100vw; height: 100vh; }
        
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #title-screen {
            background: rgba(0,0,0,0.8); inset: 0; position: absolute; pointer-events: auto;
            display: flex; flex-direction: column; justify-content: center; align-items: center; color: white;
            text-align: center; z-index: 100;
        }
        h1 { font-size: 50px; color: #00ff66; text-shadow: 0 0 10px #00ff66; margin: 0; letter-spacing: 5px; }
        p { font-size: 18px; color: #ccc; margin-bottom: 30px; line-height: 1.6; }
        button {
            padding: 15px 40px; font-size: 24px; font-weight: bold; color: #000; background: #00ff66;
            border: none; border-radius: 30px; cursor: pointer; box-shadow: 0 0 15px #00ff66;
            animation: pulse 1s infinite alternate;
        }
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }

        #height-meter {
            position: absolute; top: 20px; right: 20px; color: white; font-size: 24px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div id="height-meter">0m</div>
        <div id="title-screen">
            <h1>NEBBY CLIMB</h1>
            <p>【操作方法】<br>タップ：手を飛ばす<br>長押し：引っ張る（縮む）<br>離す：手を離す<br><br>振り子を使って上を目指せ！</p>
            <button id="start-btn">START GAME</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>

    <script>
        // --- 音響システム ---
        const Sfx = {
            ctx: null,
            init: function() {
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
            },
            play: function(type) {
                if(!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                if(type === 'shoot') {
                    osc.type = 'triangle';
                    osc.frequency.setValueAtTime(600, t);
                    osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
                    gain.gain.setValueAtTime(0.3, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.15);
                } else if(type === 'stick') {
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(200, t);
                    osc.frequency.exponentialRampToValueAtTime(50, t + 0.1);
                    gain.gain.setValueAtTime(0.5, t);
                    gain.gain.linearRampToValueAtTime(0, t + 0.1);
                }
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(t + 0.2);
            }
        };

        // --- ゲームエンジン設定 ---
        const Engine = Matter.Engine,
              Render = Matter.Render,
              Runner = Matter.Runner,
              Bodies = Matter.Bodies,
              Composite = Matter.Composite,
              Constraint = Matter.Constraint,
              Events = Matter.Events,
              Vector = Matter.Vector,
              Body = Matter.Body;

        let engine, render, runner;
        let player, hand, armConstraint;
        let isDragging = false;
        let handState = 'IDLE'; 
        let stickConstraint = null;

        const CAT_PLAYER = 0x0001, CAT_WALL = 0x0002, CAT_HAND = 0x0004;

        window.onload = () => {
            const btn = document.getElementById('start-btn');
            btn.onclick = () => {
                Sfx.init();
                document.getElementById('title-screen').style.display = 'none';
                initGame();
            };
        };

        function initGame() {
            if(engine) return; // 二重起動防止

            engine = Engine.create();
            engine.world.gravity.y = 1.2;

            render = Render.create({
                element: document.body,
                engine: engine,
                options: {
                    width: window.innerWidth,
                    height: window.innerHeight,
                    wireframes: false,
                    background: '#222'
                }
            });

            // プレイヤー
            player = Bodies.circle(0, 0, 20, {
                density: 0.005,
                frictionAir: 0.01,
                restitution: 0.2,
                collisionFilter: { category: CAT_PLAYER, mask: CAT_WALL },
                render: { fillStyle: '#ffcc00', strokeStyle: '#fff', lineWidth: 2 }
            });

            // 手
            hand = Bodies.circle(0, 0, 8, {
                isSensor: true,
                density: 0.001,
                collisionFilter: { category: CAT_HAND, mask: CAT_WALL },
                render: { fillStyle: '#00ff66' }
            });

            createLevel();
            Composite.add(engine.world, [player, hand]);

            const canvas = render.canvas;
            
            // 操作イベント (PC & スマホ両対応)
            canvas.addEventListener('pointerdown', (e) => {
                isDragging = true;
                handleInput(e);
            });
            canvas.addEventListener('pointerup', () => {
                isDragging = false;
                releaseHand();
            });

            Events.on(engine, 'collisionStart', (event) => {
                const pairs = event.pairs;
                for (let i = 0; i < pairs.length; i++) {
                    const pair = pairs[i];
                    if ((pair.bodyA === hand || pair.bodyB === hand) && handState === 'FIRING') {
                        const wall = pair.bodyA === hand ? pair.bodyB : pair.bodyA;
                        stickHand(wall, pair.collision.supports[0]);
                    }
                }
            });

            Events.on(engine, 'beforeUpdate', () => {
                updateGameLogic();
                updateCamera();
            });
            
            Events.on(render, 'afterRender', () => {
                drawArm();
            });

            Render.run(render);
            runner = Runner.create();
            Runner.run(runner, engine);
        }

        function createLevel() {
            const walls = [];
            
            // 床
            walls.push(Bodies.rectangle(0, 200, 600, 50, { isStatic: true, render: { fillStyle: '#555' } }));

            // ステージ生成
            let y = 0;
            for(let i=0; i<60; i++) {
                y -= 150 + Math.random() * 50;
                const x = (Math.random() - 0.5) * (window.innerWidth * 0.8);
                const w = 100 + Math.random() * 200;
                const angle = Math.random() > 0.8 ? Math.PI / 4 : 0;

                walls.push(Bodies.rectangle(x, y, w, 30, { 
                    isStatic: true, 
                    angle: angle,
                    collisionFilter: { category: CAT_WALL },
                    render: { fillStyle: '#667788' }
                }));
            }
            Composite.add(engine.world, walls);
        }

        function handleInput(e) {
            if (handState === 'IDLE') {
                const rect = render.canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const worldX = mouseX + render.bounds.min.x;
                const worldY = mouseY + render.bounds.min.y;
                fireHand(worldX, worldY);
            }
        }

        function fireHand(tx, ty) {
            handState = 'FIRING';
            Sfx.play('shoot');
            Body.setPosition(hand, player.position);
            Body.setVelocity(hand, { x: 0, y: 0 });

            armConstraint = Constraint.create({
                bodyA: player, bodyB: hand, length: 300, stiffness: 0.05, render: { visible: false }
            });
            Composite.add(engine.world, armConstraint);

            const force = 0.04;
            const dir = Vector.sub({ x: tx, y: ty }, player.position);
            Body.applyForce(hand, hand.position, Vector.mult(Vector.normalise(dir), force));
        }

        function stickHand(wall, point) {
            if(handState === 'STUCK') return;
            handState = 'STUCK';
            Sfx.play('stick');
            Body.setVelocity(hand, { x: 0, y: 0 });
            if(point) Body.setPosition(hand, point);

            stickConstraint = Constraint.create({
                bodyA: wall, bodyB: hand, pointB: { x: 0, y: 0 },
                pointA: Vector.sub(hand.position, wall.position),
                stiffness: 1, length: 0, render: { visible: false }
            });
            Composite.add(engine.world, stickConstraint);

            Composite.remove(engine.world, armConstraint);
            const dist = Vector.magnitude(Vector.sub(player.position, hand.position));
            armConstraint = Constraint.create({
                bodyA: player, bodyB: hand, length: dist, stiffness: 0.02, damping: 0.05, render: { visible: false }
            });
            Composite.add(engine.world, armConstraint);
        }

        function releaseHand() {
            if(handState === 'STUCK') {
                if(stickConstraint) Composite.remove(engine.world, stickConstraint);
                stickConstraint = null;
            }
            if(armConstraint) Composite.remove(engine.world, armConstraint);
            armConstraint = null;
            handState = 'IDLE';
            Body.setPosition(hand, player.position);
        }

        function updateGameLogic() {
            if(handState === 'IDLE') {
                Body.setPosition(hand, player.position);
            }
            if(handState === 'STUCK' && isDragging && armConstraint) {
                if(armConstraint.length > 20) {
                    armConstraint.length -= 12; // 縮む速度
                    armConstraint.stiffness = 0.1;
                }
            }
            // 高さ
            const h = Math.floor(Math.abs(Math.min(0, player.position.y - 200)) / 10);
            document.getElementById('height-meter').innerText = h + "m";
        }

        function updateCamera() {
            const h = render.options.height;
            const targetY = player.position.y - h * 0.3;
            const currentY = render.bounds.min.y;
            const lerpY = currentY + (targetY - currentY) * 0.1;
            Render.lookAt(render, {
                min: { x: -render.options.width / 2, y: lerpY },
                max: { x: render.options.width / 2, y: lerpY + h }
            });
        }

        function drawArm() {
            if (handState === 'IDLE') return;
            const ctx = render.context;
            const s = player.position;
            const e = hand.position;

            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            if(handState === 'STUCK' && isDragging) {
                ctx.lineTo(e.x, e.y);
                ctx.strokeStyle = '#00ff66';
                ctx.lineWidth = Math.max(2, 10 - (Vector.magnitude(Vector.sub(s, e)) / 50));
            } else {
                ctx.quadraticCurveTo((s.x+e.x)/2, (s.y+e.y)/2+20, e.x, e.y);
                ctx.strokeStyle = '#00cc55';
                ctx.lineWidth = 5;
            }
            ctx.lineCap = 'round';
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(e.x, e.y, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#00ff66';
            ctx.fill();
        }
    </script>
</body>
</html>
